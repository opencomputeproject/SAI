[%- ######################################################################## -%]

[%- BLOCK dev_utils_imports %]
from __future__ import print_function
from collections import defaultdict
from collections import Counter
[% IF NOT skip_error %]from functools import wraps[% END %]
[% END -%]

[%- BLOCK skip_test_on_error_imports %]
from functools import wraps
from unittest import SkipTest
from ptf import testutils
[% END -%]

[%- BLOCK invocation_logger_imports %]
import inspect 
import logging
[% END -%]

[%- ######################################################################## -%]

[%- ######################################################################## -%]

[%- BLOCK dev_utils %]

# dev utils

[% PROCESS instance_counter %]
[% END -%]

[%- BLOCK skip_error %]

# skip_error

[% PROCESS skip_test_on_error %]
[% END -%]

[%- BLOCK invocation_logger %]

# invocation_logger

[% PROCESS invocation_logger_func %]
[% END -%]

[%- ######################################################################## -%]

[%- ######################################################################## -%]

[%- BLOCK instance_counter -%]
def instance_counter(name=None, operation="other", log=False, zero=False):
    """
    Decorator that helps to count SAI object of 'name' instances,
    basing on defined operations.
    For "create", the correct ID should be returned by the called function.
    For "remove", the ID is passed as the second argumentof the called
    function.

    Usage:
        @instance_counter("vlan", "create")
        def sai_thrift_create_vlan(client,
                                   ...)
            ...

        @instance_counter("vlan", "remove")
        def sai_thrift_remove_vlan(client,
                                   vlan_oid):
            ...

        @instance_counter("vlan", "stats")
        def sai_thrift_get_vlan_stats(client,
                                      vlan_oid):
            ...

        print("All function calls:", instance_counter.calls)

        print("All operations attempts:", instance_counter.operations)

        print("All objects instances:", instance_counter.instances)

        print("All objects created:", instance_counter.created)

        print("All objects removed:", instance_counter.removed)

        print("All objects failed to be removed:",
              instance_counter.not_removed)

        print("sai_thrift_create_vlan() calls:",
              instance_counter.calls['sai_thrift_create_vlan'])

        print("All operations on VLAN:",
              instance_counter.operations['vlan'])

        print("All attempts to get VLAN stats:",
              instance_counter.operations['vlan']['stats'])

        print("All attempts to create VLAN:",
              instance_counter.operations['vlan']['create'])

        print("All existing VLAN instances:",
              instance_counter.instances['vlan'])

        print("All SUCCESSFULLY created VLAN objects:",
              instance_counter.created['vlan'])

        print("All SUCCESSFULLY removed VLAN objects:",
              instance_counter.removed['vlan'])

        print("All VLAN objects removal failures:",
              instance_counter.not_removed['vlan'])

        print("VLAN create-delete delta:", instance_counter.created['vlan'] -
              instance_counter.removed['vlan'])

    Args:
        name(Optional[str]): name of object
        operation(str): the operation performed on the object (e.g. remove)
        log(bool): decides whether the function should inform about calling it
        zero(bool): decides whether the '0' counters should be kept
    Returns:
        Callable[[Callable[..., Any]], Callable[..., Any]]: decorator
    """

    def instance_counter_decorator(func):
        """
        count SAI object instances basing on function calls

        Args:
            func(Callable[..., Any]): the function to be decorated
        Returns:
            Callable[..., Any]: decorated function
        """
        @wraps(func)
        def decorated(*args, **kwargs):
            """
            increment counts and call the original function

            Args:
                args(List): original args
                kwargs(Dict): original kwargs
            Returns:
                retval(Any): the original return value
            """
            if log:
                print("Calling " + func.__name__ + "()")

            instance_counter.calls[func.__name__] += 1
            instance_counter.operations[operation][name] += 1

            retval = func(*args, **kwargs)

            if name:
                if retval and operation == "create":
                    instance_counter.instances[name][retval] += 1
                    instance_counter.created[name][retval] += 1

                if operation == "remove" and isinstance(args[1], (int, long)):
                    if retval == SAI_STATUS_SUCCESS:
                        if instance_counter.instances[name][args[1]]:
                            instance_counter.instances[name][args[1]] -= 1
                        instance_counter.removed[name][args[1]] += 1
                    else:
                        instance_counter.not_removed[name][args[1]] += 1

                # remove empty counters
                if not zero:
                    instance_counter.instances[name] += Counter()
                    if not sum(instance_counter.instances[name].itervalues()):
                        instance_counter.instances.pop(name)

            return retval
        return decorated
    return instance_counter_decorator


# All function calls
instance_counter.calls = Counter()

# All operations attempts
instance_counter.operations = defaultdict(Counter)

# Special create/remove counters
instance_counter.instances = defaultdict(Counter)
instance_counter.created = defaultdict(Counter)
instance_counter.removed = defaultdict(Counter)
instance_counter.not_removed = defaultdict(Counter)
[%- END -%]

[%- BLOCK skip_test_on_error -%]
def skip_test_on_error(errorcode=[-2]):
    def skip_test_on_error_decorator(func):
        """
        Decorator for skip the test when error happened.
        Args:
            errorcode: a list of the error code that test will be skipped.
        """

        @wraps(func)
        def decorated(*args, **kwargs):
            """
            Check the return value and check if the status is the error code
            on which the test should be skipped.

            Args:
                args(List): original args
                kwargs(Dict): original kwargs
            Returns:
                retval(Any): the original return value
            """
            retval = func(*args, **kwargs)
            global status             
            if status in errorcode:
                reason = "SkipTest: {} with errorcode: {}".format(func.__name__, status)
                print(reason)
                testutils.skipped_test_count=1
                raise SkipTest(reason)
            return retval
        return decorated
    return skip_test_on_error_decorator
[%- END -%]

[%- BLOCK invocation_logger_func -%]
def invocation_logger(func):
    """
    SAI interface invocation logger.
    Use it to log all the invocated method in this sai_adapater.
    """
     
    def inner_logger(*args, **kwargs):
 
        args_name = inspect.getargspec(func)[0]

        args_dict = dict(zip(args_name, args))
        args_dict.update(kwargs)
        args_dict = { key:str(value) for (key,value) in args_dict.items()}
        logging.info("sai_adapter_invoke func:[{}] args: [{}]".format(func.__name__, args_dict))

        args_values = args_dict.values()

        retval = func(*args, **kwargs)
        # Base on some vendor's requirement, 
        # need to convert all the values in the dict to a string
        retDict = eval(repr(retval))
        if type(retDict) is dict:
            retDict = { key:str(value) for (key,value) in retDict.items()}
            logging.info("sai_adapter_return func:[{}] retval:[{}]".format(func.__name__, retDict))
        else:
            logging.info("sai_adapter_return func:[{}] retval:[{}]".format(func.__name__, repr(retval)))
        return retval
 
    return inner_logger
[%- END -%]

[%- ######################################################################## -%]

[%- ######################################################################## -%]

[%- BLOCK decorate_method %]
@instance_counter("[% function.object %]", "[% function.operation %]"[% IF dev_utils.match('log') %], log=True[% END %][% IF dev_utils.match('zero') %], zero=True[% END %])
[%- END -%]

[%- BLOCK decorate_skip_test_on_error %]
@skip_test_on_error([% IF skip_error %]errorcode=[[% skip_error %]][% END %])
[%- END -%]

[%- BLOCK decorate_invocation_logger %]
@invocation_logger
[%- END -%]

[%- ######################################################################## -%]
