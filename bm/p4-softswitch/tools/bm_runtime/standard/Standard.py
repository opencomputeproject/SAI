#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def bm_mt_get_num_entries(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    pass

  def bm_mt_add_entry(self, cxt_id, table_name, match_key, action_name, action_data, options):
    """
    Parameters:
     - cxt_id
     - table_name
     - match_key
     - action_name
     - action_data
     - options
    """
    pass

  def bm_mt_set_default_action(self, cxt_id, table_name, action_name, action_data):
    """
    Parameters:
     - cxt_id
     - table_name
     - action_name
     - action_data
    """
    pass

  def bm_mt_delete_entry(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    pass

  def bm_mt_modify_entry(self, cxt_id, table_name, entry_handle, action_name, action_data):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - action_name
     - action_data
    """
    pass

  def bm_mt_set_entry_ttl(self, cxt_id, table_name, entry_handle, timeout_ms):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - timeout_ms
    """
    pass

  def bm_mt_indirect_add_member(self, cxt_id, table_name, action_name, action_data):
    """
    Parameters:
     - cxt_id
     - table_name
     - action_name
     - action_data
    """
    pass

  def bm_mt_indirect_delete_member(self, cxt_id, table_name, mbr_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
    """
    pass

  def bm_mt_indirect_modify_member(self, cxt_id, table_name, mbr_handle, action_name, action_data):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
     - action_name
     - action_data
    """
    pass

  def bm_mt_indirect_add_entry(self, cxt_id, table_name, match_key, mbr_handle, options):
    """
    Parameters:
     - cxt_id
     - table_name
     - match_key
     - mbr_handle
     - options
    """
    pass

  def bm_mt_indirect_modify_entry(self, cxt_id, table_name, entry_handle, mbr_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - mbr_handle
    """
    pass

  def bm_mt_indirect_delete_entry(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    pass

  def bm_mt_indirect_set_entry_ttl(self, cxt_id, table_name, entry_handle, timeout_ms):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - timeout_ms
    """
    pass

  def bm_mt_indirect_set_default_member(self, cxt_id, table_name, mbr_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
    """
    pass

  def bm_mt_indirect_ws_create_group(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    pass

  def bm_mt_indirect_ws_delete_group(self, cxt_id, table_name, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - grp_handle
    """
    pass

  def bm_mt_indirect_ws_add_member_to_group(self, cxt_id, table_name, mbr_handle, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
     - grp_handle
    """
    pass

  def bm_mt_indirect_ws_remove_member_from_group(self, cxt_id, table_name, mbr_handle, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
     - grp_handle
    """
    pass

  def bm_mt_indirect_ws_add_entry(self, cxt_id, table_name, match_key, grp_handle, options):
    """
    Parameters:
     - cxt_id
     - table_name
     - match_key
     - grp_handle
     - options
    """
    pass

  def bm_mt_indirect_ws_modify_entry(self, cxt_id, table_name, entry_handle, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - grp_handle
    """
    pass

  def bm_mt_indirect_ws_set_default_group(self, cxt_id, table_name, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - grp_handle
    """
    pass

  def bm_mt_read_counter(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    pass

  def bm_mt_reset_counters(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    pass

  def bm_mt_write_counter(self, cxt_id, table_name, entry_handle, value):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - value
    """
    pass

  def bm_mt_set_meter_rates(self, cxt_id, table_name, entry_handle, rates):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - rates
    """
    pass

  def bm_mt_get_meter_rates(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    pass

  def bm_mt_get_entries(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    pass

  def bm_mt_get_entry(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    pass

  def bm_mt_get_default_entry(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    pass

  def bm_mt_get_entry_from_key(self, cxt_id, table_name, match_key, options):
    """
    Parameters:
     - cxt_id
     - table_name
     - match_key
     - options
    """
    pass

  def bm_mt_indirect_get_members(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    pass

  def bm_mt_indirect_get_member(self, cxt_id, table_name, mbr_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
    """
    pass

  def bm_mt_indirect_ws_get_groups(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    pass

  def bm_mt_indirect_ws_get_group(self, cxt_id, table_name, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - grp_handle
    """
    pass

  def bm_counter_read(self, cxt_id, counter_name, index):
    """
    Parameters:
     - cxt_id
     - counter_name
     - index
    """
    pass

  def bm_counter_reset_all(self, cxt_id, counter_name):
    """
    Parameters:
     - cxt_id
     - counter_name
    """
    pass

  def bm_counter_write(self, cxt_id, counter_name, index, value):
    """
    Parameters:
     - cxt_id
     - counter_name
     - index
     - value
    """
    pass

  def bm_learning_ack(self, cxt_id, list_id, buffer_id, sample_ids):
    """
    Parameters:
     - cxt_id
     - list_id
     - buffer_id
     - sample_ids
    """
    pass

  def bm_learning_ack_buffer(self, cxt_id, list_id, buffer_id):
    """
    Parameters:
     - cxt_id
     - list_id
     - buffer_id
    """
    pass

  def bm_learning_set_timeout(self, cxt_id, list_id, timeout_ms):
    """
    Parameters:
     - cxt_id
     - list_id
     - timeout_ms
    """
    pass

  def bm_learning_set_buffer_size(self, cxt_id, list_id, nb_samples):
    """
    Parameters:
     - cxt_id
     - list_id
     - nb_samples
    """
    pass

  def bm_load_new_config(self, config_str):
    """
    Parameters:
     - config_str
    """
    pass

  def bm_swap_configs(self):
    pass

  def bm_meter_array_set_rates(self, cxt_id, meter_array_name, rates):
    """
    Parameters:
     - cxt_id
     - meter_array_name
     - rates
    """
    pass

  def bm_meter_set_rates(self, cxt_id, meter_array_name, index, rates):
    """
    Parameters:
     - cxt_id
     - meter_array_name
     - index
     - rates
    """
    pass

  def bm_meter_get_rates(self, cxt_id, meter_array_name, index):
    """
    Parameters:
     - cxt_id
     - meter_array_name
     - index
    """
    pass

  def bm_register_read(self, cxt_id, register_array_name, idx):
    """
    Parameters:
     - cxt_id
     - register_array_name
     - idx
    """
    pass

  def bm_register_write(self, cxt_id, register_array_name, index, value):
    """
    Parameters:
     - cxt_id
     - register_array_name
     - index
     - value
    """
    pass

  def bm_register_write_range(self, cxt_id, register_array_name, start_index, end_index, value):
    """
    Parameters:
     - cxt_id
     - register_array_name
     - start_index
     - end_index
     - value
    """
    pass

  def bm_register_reset(self, cxt_id, register_array_name):
    """
    Parameters:
     - cxt_id
     - register_array_name
    """
    pass

  def bm_parse_vset_add(self, cxt_id, parse_vset_name, value):
    """
    Parameters:
     - cxt_id
     - parse_vset_name
     - value
    """
    pass

  def bm_parse_vset_remove(self, cxt_id, parse_vset_name, value):
    """
    Parameters:
     - cxt_id
     - parse_vset_name
     - value
    """
    pass

  def bm_dev_mgr_add_port(self, iface_name, port_num, pcap_path):
    """
    Parameters:
     - iface_name
     - port_num
     - pcap_path
    """
    pass

  def bm_dev_mgr_remove_port(self, port_num):
    """
    Parameters:
     - port_num
    """
    pass

  def bm_dev_mgr_show_ports(self):
    pass

  def bm_mgmt_get_info(self):
    pass

  def bm_set_crc16_custom_parameters(self, cxt_id, calc_name, crc16_config):
    """
    Parameters:
     - cxt_id
     - calc_name
     - crc16_config
    """
    pass

  def bm_set_crc32_custom_parameters(self, cxt_id, calc_name, crc32_config):
    """
    Parameters:
     - cxt_id
     - calc_name
     - crc32_config
    """
    pass

  def bm_reset_state(self):
    pass

  def bm_get_config(self):
    pass

  def bm_get_config_md5(self):
    pass

  def bm_serialize_state(self):
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def bm_mt_get_num_entries(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    self.send_bm_mt_get_num_entries(cxt_id, table_name)
    return self.recv_bm_mt_get_num_entries()

  def send_bm_mt_get_num_entries(self, cxt_id, table_name):
    self._oprot.writeMessageBegin('bm_mt_get_num_entries', TMessageType.CALL, self._seqid)
    args = bm_mt_get_num_entries_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_get_num_entries(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_get_num_entries_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_get_num_entries failed: unknown result");

  def bm_mt_add_entry(self, cxt_id, table_name, match_key, action_name, action_data, options):
    """
    Parameters:
     - cxt_id
     - table_name
     - match_key
     - action_name
     - action_data
     - options
    """
    self.send_bm_mt_add_entry(cxt_id, table_name, match_key, action_name, action_data, options)
    return self.recv_bm_mt_add_entry()

  def send_bm_mt_add_entry(self, cxt_id, table_name, match_key, action_name, action_data, options):
    self._oprot.writeMessageBegin('bm_mt_add_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_add_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.match_key = match_key
    args.action_name = action_name
    args.action_data = action_data
    args.options = options
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_add_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_add_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_add_entry failed: unknown result");

  def bm_mt_set_default_action(self, cxt_id, table_name, action_name, action_data):
    """
    Parameters:
     - cxt_id
     - table_name
     - action_name
     - action_data
    """
    self.send_bm_mt_set_default_action(cxt_id, table_name, action_name, action_data)
    self.recv_bm_mt_set_default_action()

  def send_bm_mt_set_default_action(self, cxt_id, table_name, action_name, action_data):
    self._oprot.writeMessageBegin('bm_mt_set_default_action', TMessageType.CALL, self._seqid)
    args = bm_mt_set_default_action_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.action_name = action_name
    args.action_data = action_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_set_default_action(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_set_default_action_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_delete_entry(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    self.send_bm_mt_delete_entry(cxt_id, table_name, entry_handle)
    self.recv_bm_mt_delete_entry()

  def send_bm_mt_delete_entry(self, cxt_id, table_name, entry_handle):
    self._oprot.writeMessageBegin('bm_mt_delete_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_delete_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_delete_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_delete_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_modify_entry(self, cxt_id, table_name, entry_handle, action_name, action_data):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - action_name
     - action_data
    """
    self.send_bm_mt_modify_entry(cxt_id, table_name, entry_handle, action_name, action_data)
    self.recv_bm_mt_modify_entry()

  def send_bm_mt_modify_entry(self, cxt_id, table_name, entry_handle, action_name, action_data):
    self._oprot.writeMessageBegin('bm_mt_modify_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_modify_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.action_name = action_name
    args.action_data = action_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_modify_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_modify_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_set_entry_ttl(self, cxt_id, table_name, entry_handle, timeout_ms):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - timeout_ms
    """
    self.send_bm_mt_set_entry_ttl(cxt_id, table_name, entry_handle, timeout_ms)
    self.recv_bm_mt_set_entry_ttl()

  def send_bm_mt_set_entry_ttl(self, cxt_id, table_name, entry_handle, timeout_ms):
    self._oprot.writeMessageBegin('bm_mt_set_entry_ttl', TMessageType.CALL, self._seqid)
    args = bm_mt_set_entry_ttl_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.timeout_ms = timeout_ms
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_set_entry_ttl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_set_entry_ttl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_add_member(self, cxt_id, table_name, action_name, action_data):
    """
    Parameters:
     - cxt_id
     - table_name
     - action_name
     - action_data
    """
    self.send_bm_mt_indirect_add_member(cxt_id, table_name, action_name, action_data)
    return self.recv_bm_mt_indirect_add_member()

  def send_bm_mt_indirect_add_member(self, cxt_id, table_name, action_name, action_data):
    self._oprot.writeMessageBegin('bm_mt_indirect_add_member', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_add_member_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.action_name = action_name
    args.action_data = action_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_add_member(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_add_member_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_indirect_add_member failed: unknown result");

  def bm_mt_indirect_delete_member(self, cxt_id, table_name, mbr_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
    """
    self.send_bm_mt_indirect_delete_member(cxt_id, table_name, mbr_handle)
    self.recv_bm_mt_indirect_delete_member()

  def send_bm_mt_indirect_delete_member(self, cxt_id, table_name, mbr_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_delete_member', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_delete_member_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.mbr_handle = mbr_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_delete_member(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_delete_member_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_modify_member(self, cxt_id, table_name, mbr_handle, action_name, action_data):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
     - action_name
     - action_data
    """
    self.send_bm_mt_indirect_modify_member(cxt_id, table_name, mbr_handle, action_name, action_data)
    self.recv_bm_mt_indirect_modify_member()

  def send_bm_mt_indirect_modify_member(self, cxt_id, table_name, mbr_handle, action_name, action_data):
    self._oprot.writeMessageBegin('bm_mt_indirect_modify_member', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_modify_member_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.mbr_handle = mbr_handle
    args.action_name = action_name
    args.action_data = action_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_modify_member(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_modify_member_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_add_entry(self, cxt_id, table_name, match_key, mbr_handle, options):
    """
    Parameters:
     - cxt_id
     - table_name
     - match_key
     - mbr_handle
     - options
    """
    self.send_bm_mt_indirect_add_entry(cxt_id, table_name, match_key, mbr_handle, options)
    return self.recv_bm_mt_indirect_add_entry()

  def send_bm_mt_indirect_add_entry(self, cxt_id, table_name, match_key, mbr_handle, options):
    self._oprot.writeMessageBegin('bm_mt_indirect_add_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_add_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.match_key = match_key
    args.mbr_handle = mbr_handle
    args.options = options
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_add_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_add_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_indirect_add_entry failed: unknown result");

  def bm_mt_indirect_modify_entry(self, cxt_id, table_name, entry_handle, mbr_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - mbr_handle
    """
    self.send_bm_mt_indirect_modify_entry(cxt_id, table_name, entry_handle, mbr_handle)
    self.recv_bm_mt_indirect_modify_entry()

  def send_bm_mt_indirect_modify_entry(self, cxt_id, table_name, entry_handle, mbr_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_modify_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_modify_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.mbr_handle = mbr_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_modify_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_modify_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_delete_entry(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    self.send_bm_mt_indirect_delete_entry(cxt_id, table_name, entry_handle)
    self.recv_bm_mt_indirect_delete_entry()

  def send_bm_mt_indirect_delete_entry(self, cxt_id, table_name, entry_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_delete_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_delete_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_delete_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_delete_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_set_entry_ttl(self, cxt_id, table_name, entry_handle, timeout_ms):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - timeout_ms
    """
    self.send_bm_mt_indirect_set_entry_ttl(cxt_id, table_name, entry_handle, timeout_ms)
    self.recv_bm_mt_indirect_set_entry_ttl()

  def send_bm_mt_indirect_set_entry_ttl(self, cxt_id, table_name, entry_handle, timeout_ms):
    self._oprot.writeMessageBegin('bm_mt_indirect_set_entry_ttl', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_set_entry_ttl_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.timeout_ms = timeout_ms
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_set_entry_ttl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_set_entry_ttl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_set_default_member(self, cxt_id, table_name, mbr_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
    """
    self.send_bm_mt_indirect_set_default_member(cxt_id, table_name, mbr_handle)
    self.recv_bm_mt_indirect_set_default_member()

  def send_bm_mt_indirect_set_default_member(self, cxt_id, table_name, mbr_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_set_default_member', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_set_default_member_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.mbr_handle = mbr_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_set_default_member(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_set_default_member_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_ws_create_group(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    self.send_bm_mt_indirect_ws_create_group(cxt_id, table_name)
    return self.recv_bm_mt_indirect_ws_create_group()

  def send_bm_mt_indirect_ws_create_group(self, cxt_id, table_name):
    self._oprot.writeMessageBegin('bm_mt_indirect_ws_create_group', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_ws_create_group_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_ws_create_group(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_ws_create_group_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_indirect_ws_create_group failed: unknown result");

  def bm_mt_indirect_ws_delete_group(self, cxt_id, table_name, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - grp_handle
    """
    self.send_bm_mt_indirect_ws_delete_group(cxt_id, table_name, grp_handle)
    self.recv_bm_mt_indirect_ws_delete_group()

  def send_bm_mt_indirect_ws_delete_group(self, cxt_id, table_name, grp_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_ws_delete_group', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_ws_delete_group_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.grp_handle = grp_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_ws_delete_group(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_ws_delete_group_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_ws_add_member_to_group(self, cxt_id, table_name, mbr_handle, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
     - grp_handle
    """
    self.send_bm_mt_indirect_ws_add_member_to_group(cxt_id, table_name, mbr_handle, grp_handle)
    self.recv_bm_mt_indirect_ws_add_member_to_group()

  def send_bm_mt_indirect_ws_add_member_to_group(self, cxt_id, table_name, mbr_handle, grp_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_ws_add_member_to_group', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_ws_add_member_to_group_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.mbr_handle = mbr_handle
    args.grp_handle = grp_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_ws_add_member_to_group(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_ws_add_member_to_group_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_ws_remove_member_from_group(self, cxt_id, table_name, mbr_handle, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
     - grp_handle
    """
    self.send_bm_mt_indirect_ws_remove_member_from_group(cxt_id, table_name, mbr_handle, grp_handle)
    self.recv_bm_mt_indirect_ws_remove_member_from_group()

  def send_bm_mt_indirect_ws_remove_member_from_group(self, cxt_id, table_name, mbr_handle, grp_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_ws_remove_member_from_group', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_ws_remove_member_from_group_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.mbr_handle = mbr_handle
    args.grp_handle = grp_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_ws_remove_member_from_group(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_ws_remove_member_from_group_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_ws_add_entry(self, cxt_id, table_name, match_key, grp_handle, options):
    """
    Parameters:
     - cxt_id
     - table_name
     - match_key
     - grp_handle
     - options
    """
    self.send_bm_mt_indirect_ws_add_entry(cxt_id, table_name, match_key, grp_handle, options)
    return self.recv_bm_mt_indirect_ws_add_entry()

  def send_bm_mt_indirect_ws_add_entry(self, cxt_id, table_name, match_key, grp_handle, options):
    self._oprot.writeMessageBegin('bm_mt_indirect_ws_add_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_ws_add_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.match_key = match_key
    args.grp_handle = grp_handle
    args.options = options
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_ws_add_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_ws_add_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_indirect_ws_add_entry failed: unknown result");

  def bm_mt_indirect_ws_modify_entry(self, cxt_id, table_name, entry_handle, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - grp_handle
    """
    self.send_bm_mt_indirect_ws_modify_entry(cxt_id, table_name, entry_handle, grp_handle)
    self.recv_bm_mt_indirect_ws_modify_entry()

  def send_bm_mt_indirect_ws_modify_entry(self, cxt_id, table_name, entry_handle, grp_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_ws_modify_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_ws_modify_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.grp_handle = grp_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_ws_modify_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_ws_modify_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_indirect_ws_set_default_group(self, cxt_id, table_name, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - grp_handle
    """
    self.send_bm_mt_indirect_ws_set_default_group(cxt_id, table_name, grp_handle)
    self.recv_bm_mt_indirect_ws_set_default_group()

  def send_bm_mt_indirect_ws_set_default_group(self, cxt_id, table_name, grp_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_ws_set_default_group', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_ws_set_default_group_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.grp_handle = grp_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_ws_set_default_group(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_ws_set_default_group_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_read_counter(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    self.send_bm_mt_read_counter(cxt_id, table_name, entry_handle)
    return self.recv_bm_mt_read_counter()

  def send_bm_mt_read_counter(self, cxt_id, table_name, entry_handle):
    self._oprot.writeMessageBegin('bm_mt_read_counter', TMessageType.CALL, self._seqid)
    args = bm_mt_read_counter_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_read_counter(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_read_counter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_read_counter failed: unknown result");

  def bm_mt_reset_counters(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    self.send_bm_mt_reset_counters(cxt_id, table_name)
    self.recv_bm_mt_reset_counters()

  def send_bm_mt_reset_counters(self, cxt_id, table_name):
    self._oprot.writeMessageBegin('bm_mt_reset_counters', TMessageType.CALL, self._seqid)
    args = bm_mt_reset_counters_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_reset_counters(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_reset_counters_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_write_counter(self, cxt_id, table_name, entry_handle, value):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - value
    """
    self.send_bm_mt_write_counter(cxt_id, table_name, entry_handle, value)
    self.recv_bm_mt_write_counter()

  def send_bm_mt_write_counter(self, cxt_id, table_name, entry_handle, value):
    self._oprot.writeMessageBegin('bm_mt_write_counter', TMessageType.CALL, self._seqid)
    args = bm_mt_write_counter_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_write_counter(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_write_counter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_set_meter_rates(self, cxt_id, table_name, entry_handle, rates):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
     - rates
    """
    self.send_bm_mt_set_meter_rates(cxt_id, table_name, entry_handle, rates)
    self.recv_bm_mt_set_meter_rates()

  def send_bm_mt_set_meter_rates(self, cxt_id, table_name, entry_handle, rates):
    self._oprot.writeMessageBegin('bm_mt_set_meter_rates', TMessageType.CALL, self._seqid)
    args = bm_mt_set_meter_rates_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.rates = rates
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_set_meter_rates(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_set_meter_rates_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_mt_get_meter_rates(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    self.send_bm_mt_get_meter_rates(cxt_id, table_name, entry_handle)
    return self.recv_bm_mt_get_meter_rates()

  def send_bm_mt_get_meter_rates(self, cxt_id, table_name, entry_handle):
    self._oprot.writeMessageBegin('bm_mt_get_meter_rates', TMessageType.CALL, self._seqid)
    args = bm_mt_get_meter_rates_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_get_meter_rates(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_get_meter_rates_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_get_meter_rates failed: unknown result");

  def bm_mt_get_entries(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    self.send_bm_mt_get_entries(cxt_id, table_name)
    return self.recv_bm_mt_get_entries()

  def send_bm_mt_get_entries(self, cxt_id, table_name):
    self._oprot.writeMessageBegin('bm_mt_get_entries', TMessageType.CALL, self._seqid)
    args = bm_mt_get_entries_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_get_entries(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_get_entries_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_get_entries failed: unknown result");

  def bm_mt_get_entry(self, cxt_id, table_name, entry_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - entry_handle
    """
    self.send_bm_mt_get_entry(cxt_id, table_name, entry_handle)
    return self.recv_bm_mt_get_entry()

  def send_bm_mt_get_entry(self, cxt_id, table_name, entry_handle):
    self._oprot.writeMessageBegin('bm_mt_get_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_get_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.entry_handle = entry_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_get_entry failed: unknown result");

  def bm_mt_get_default_entry(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    self.send_bm_mt_get_default_entry(cxt_id, table_name)
    return self.recv_bm_mt_get_default_entry()

  def send_bm_mt_get_default_entry(self, cxt_id, table_name):
    self._oprot.writeMessageBegin('bm_mt_get_default_entry', TMessageType.CALL, self._seqid)
    args = bm_mt_get_default_entry_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_get_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_get_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_get_default_entry failed: unknown result");

  def bm_mt_get_entry_from_key(self, cxt_id, table_name, match_key, options):
    """
    Parameters:
     - cxt_id
     - table_name
     - match_key
     - options
    """
    self.send_bm_mt_get_entry_from_key(cxt_id, table_name, match_key, options)
    return self.recv_bm_mt_get_entry_from_key()

  def send_bm_mt_get_entry_from_key(self, cxt_id, table_name, match_key, options):
    self._oprot.writeMessageBegin('bm_mt_get_entry_from_key', TMessageType.CALL, self._seqid)
    args = bm_mt_get_entry_from_key_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.match_key = match_key
    args.options = options
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_get_entry_from_key(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_get_entry_from_key_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_get_entry_from_key failed: unknown result");

  def bm_mt_indirect_get_members(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    self.send_bm_mt_indirect_get_members(cxt_id, table_name)
    return self.recv_bm_mt_indirect_get_members()

  def send_bm_mt_indirect_get_members(self, cxt_id, table_name):
    self._oprot.writeMessageBegin('bm_mt_indirect_get_members', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_get_members_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_get_members(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_get_members_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_indirect_get_members failed: unknown result");

  def bm_mt_indirect_get_member(self, cxt_id, table_name, mbr_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - mbr_handle
    """
    self.send_bm_mt_indirect_get_member(cxt_id, table_name, mbr_handle)
    return self.recv_bm_mt_indirect_get_member()

  def send_bm_mt_indirect_get_member(self, cxt_id, table_name, mbr_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_get_member', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_get_member_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.mbr_handle = mbr_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_get_member(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_get_member_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_indirect_get_member failed: unknown result");

  def bm_mt_indirect_ws_get_groups(self, cxt_id, table_name):
    """
    Parameters:
     - cxt_id
     - table_name
    """
    self.send_bm_mt_indirect_ws_get_groups(cxt_id, table_name)
    return self.recv_bm_mt_indirect_ws_get_groups()

  def send_bm_mt_indirect_ws_get_groups(self, cxt_id, table_name):
    self._oprot.writeMessageBegin('bm_mt_indirect_ws_get_groups', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_ws_get_groups_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_ws_get_groups(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_ws_get_groups_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_indirect_ws_get_groups failed: unknown result");

  def bm_mt_indirect_ws_get_group(self, cxt_id, table_name, grp_handle):
    """
    Parameters:
     - cxt_id
     - table_name
     - grp_handle
    """
    self.send_bm_mt_indirect_ws_get_group(cxt_id, table_name, grp_handle)
    return self.recv_bm_mt_indirect_ws_get_group()

  def send_bm_mt_indirect_ws_get_group(self, cxt_id, table_name, grp_handle):
    self._oprot.writeMessageBegin('bm_mt_indirect_ws_get_group', TMessageType.CALL, self._seqid)
    args = bm_mt_indirect_ws_get_group_args()
    args.cxt_id = cxt_id
    args.table_name = table_name
    args.grp_handle = grp_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mt_indirect_ws_get_group(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mt_indirect_ws_get_group_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mt_indirect_ws_get_group failed: unknown result");

  def bm_counter_read(self, cxt_id, counter_name, index):
    """
    Parameters:
     - cxt_id
     - counter_name
     - index
    """
    self.send_bm_counter_read(cxt_id, counter_name, index)
    return self.recv_bm_counter_read()

  def send_bm_counter_read(self, cxt_id, counter_name, index):
    self._oprot.writeMessageBegin('bm_counter_read', TMessageType.CALL, self._seqid)
    args = bm_counter_read_args()
    args.cxt_id = cxt_id
    args.counter_name = counter_name
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_counter_read(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_counter_read_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_counter_read failed: unknown result");

  def bm_counter_reset_all(self, cxt_id, counter_name):
    """
    Parameters:
     - cxt_id
     - counter_name
    """
    self.send_bm_counter_reset_all(cxt_id, counter_name)
    self.recv_bm_counter_reset_all()

  def send_bm_counter_reset_all(self, cxt_id, counter_name):
    self._oprot.writeMessageBegin('bm_counter_reset_all', TMessageType.CALL, self._seqid)
    args = bm_counter_reset_all_args()
    args.cxt_id = cxt_id
    args.counter_name = counter_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_counter_reset_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_counter_reset_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_counter_write(self, cxt_id, counter_name, index, value):
    """
    Parameters:
     - cxt_id
     - counter_name
     - index
     - value
    """
    self.send_bm_counter_write(cxt_id, counter_name, index, value)
    self.recv_bm_counter_write()

  def send_bm_counter_write(self, cxt_id, counter_name, index, value):
    self._oprot.writeMessageBegin('bm_counter_write', TMessageType.CALL, self._seqid)
    args = bm_counter_write_args()
    args.cxt_id = cxt_id
    args.counter_name = counter_name
    args.index = index
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_counter_write(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_counter_write_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_learning_ack(self, cxt_id, list_id, buffer_id, sample_ids):
    """
    Parameters:
     - cxt_id
     - list_id
     - buffer_id
     - sample_ids
    """
    self.send_bm_learning_ack(cxt_id, list_id, buffer_id, sample_ids)
    self.recv_bm_learning_ack()

  def send_bm_learning_ack(self, cxt_id, list_id, buffer_id, sample_ids):
    self._oprot.writeMessageBegin('bm_learning_ack', TMessageType.CALL, self._seqid)
    args = bm_learning_ack_args()
    args.cxt_id = cxt_id
    args.list_id = list_id
    args.buffer_id = buffer_id
    args.sample_ids = sample_ids
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_learning_ack(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_learning_ack_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_learning_ack_buffer(self, cxt_id, list_id, buffer_id):
    """
    Parameters:
     - cxt_id
     - list_id
     - buffer_id
    """
    self.send_bm_learning_ack_buffer(cxt_id, list_id, buffer_id)
    self.recv_bm_learning_ack_buffer()

  def send_bm_learning_ack_buffer(self, cxt_id, list_id, buffer_id):
    self._oprot.writeMessageBegin('bm_learning_ack_buffer', TMessageType.CALL, self._seqid)
    args = bm_learning_ack_buffer_args()
    args.cxt_id = cxt_id
    args.list_id = list_id
    args.buffer_id = buffer_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_learning_ack_buffer(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_learning_ack_buffer_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_learning_set_timeout(self, cxt_id, list_id, timeout_ms):
    """
    Parameters:
     - cxt_id
     - list_id
     - timeout_ms
    """
    self.send_bm_learning_set_timeout(cxt_id, list_id, timeout_ms)
    self.recv_bm_learning_set_timeout()

  def send_bm_learning_set_timeout(self, cxt_id, list_id, timeout_ms):
    self._oprot.writeMessageBegin('bm_learning_set_timeout', TMessageType.CALL, self._seqid)
    args = bm_learning_set_timeout_args()
    args.cxt_id = cxt_id
    args.list_id = list_id
    args.timeout_ms = timeout_ms
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_learning_set_timeout(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_learning_set_timeout_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_learning_set_buffer_size(self, cxt_id, list_id, nb_samples):
    """
    Parameters:
     - cxt_id
     - list_id
     - nb_samples
    """
    self.send_bm_learning_set_buffer_size(cxt_id, list_id, nb_samples)
    self.recv_bm_learning_set_buffer_size()

  def send_bm_learning_set_buffer_size(self, cxt_id, list_id, nb_samples):
    self._oprot.writeMessageBegin('bm_learning_set_buffer_size', TMessageType.CALL, self._seqid)
    args = bm_learning_set_buffer_size_args()
    args.cxt_id = cxt_id
    args.list_id = list_id
    args.nb_samples = nb_samples
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_learning_set_buffer_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_learning_set_buffer_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_load_new_config(self, config_str):
    """
    Parameters:
     - config_str
    """
    self.send_bm_load_new_config(config_str)
    self.recv_bm_load_new_config()

  def send_bm_load_new_config(self, config_str):
    self._oprot.writeMessageBegin('bm_load_new_config', TMessageType.CALL, self._seqid)
    args = bm_load_new_config_args()
    args.config_str = config_str
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_load_new_config(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_load_new_config_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_swap_configs(self):
    self.send_bm_swap_configs()
    self.recv_bm_swap_configs()

  def send_bm_swap_configs(self):
    self._oprot.writeMessageBegin('bm_swap_configs', TMessageType.CALL, self._seqid)
    args = bm_swap_configs_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_swap_configs(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_swap_configs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_meter_array_set_rates(self, cxt_id, meter_array_name, rates):
    """
    Parameters:
     - cxt_id
     - meter_array_name
     - rates
    """
    self.send_bm_meter_array_set_rates(cxt_id, meter_array_name, rates)
    self.recv_bm_meter_array_set_rates()

  def send_bm_meter_array_set_rates(self, cxt_id, meter_array_name, rates):
    self._oprot.writeMessageBegin('bm_meter_array_set_rates', TMessageType.CALL, self._seqid)
    args = bm_meter_array_set_rates_args()
    args.cxt_id = cxt_id
    args.meter_array_name = meter_array_name
    args.rates = rates
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_meter_array_set_rates(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_meter_array_set_rates_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_meter_set_rates(self, cxt_id, meter_array_name, index, rates):
    """
    Parameters:
     - cxt_id
     - meter_array_name
     - index
     - rates
    """
    self.send_bm_meter_set_rates(cxt_id, meter_array_name, index, rates)
    self.recv_bm_meter_set_rates()

  def send_bm_meter_set_rates(self, cxt_id, meter_array_name, index, rates):
    self._oprot.writeMessageBegin('bm_meter_set_rates', TMessageType.CALL, self._seqid)
    args = bm_meter_set_rates_args()
    args.cxt_id = cxt_id
    args.meter_array_name = meter_array_name
    args.index = index
    args.rates = rates
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_meter_set_rates(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_meter_set_rates_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_meter_get_rates(self, cxt_id, meter_array_name, index):
    """
    Parameters:
     - cxt_id
     - meter_array_name
     - index
    """
    self.send_bm_meter_get_rates(cxt_id, meter_array_name, index)
    return self.recv_bm_meter_get_rates()

  def send_bm_meter_get_rates(self, cxt_id, meter_array_name, index):
    self._oprot.writeMessageBegin('bm_meter_get_rates', TMessageType.CALL, self._seqid)
    args = bm_meter_get_rates_args()
    args.cxt_id = cxt_id
    args.meter_array_name = meter_array_name
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_meter_get_rates(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_meter_get_rates_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_meter_get_rates failed: unknown result");

  def bm_register_read(self, cxt_id, register_array_name, idx):
    """
    Parameters:
     - cxt_id
     - register_array_name
     - idx
    """
    self.send_bm_register_read(cxt_id, register_array_name, idx)
    return self.recv_bm_register_read()

  def send_bm_register_read(self, cxt_id, register_array_name, idx):
    self._oprot.writeMessageBegin('bm_register_read', TMessageType.CALL, self._seqid)
    args = bm_register_read_args()
    args.cxt_id = cxt_id
    args.register_array_name = register_array_name
    args.idx = idx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_register_read(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_register_read_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_register_read failed: unknown result");

  def bm_register_write(self, cxt_id, register_array_name, index, value):
    """
    Parameters:
     - cxt_id
     - register_array_name
     - index
     - value
    """
    self.send_bm_register_write(cxt_id, register_array_name, index, value)
    self.recv_bm_register_write()

  def send_bm_register_write(self, cxt_id, register_array_name, index, value):
    self._oprot.writeMessageBegin('bm_register_write', TMessageType.CALL, self._seqid)
    args = bm_register_write_args()
    args.cxt_id = cxt_id
    args.register_array_name = register_array_name
    args.index = index
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_register_write(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_register_write_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_register_write_range(self, cxt_id, register_array_name, start_index, end_index, value):
    """
    Parameters:
     - cxt_id
     - register_array_name
     - start_index
     - end_index
     - value
    """
    self.send_bm_register_write_range(cxt_id, register_array_name, start_index, end_index, value)
    self.recv_bm_register_write_range()

  def send_bm_register_write_range(self, cxt_id, register_array_name, start_index, end_index, value):
    self._oprot.writeMessageBegin('bm_register_write_range', TMessageType.CALL, self._seqid)
    args = bm_register_write_range_args()
    args.cxt_id = cxt_id
    args.register_array_name = register_array_name
    args.start_index = start_index
    args.end_index = end_index
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_register_write_range(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_register_write_range_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_register_reset(self, cxt_id, register_array_name):
    """
    Parameters:
     - cxt_id
     - register_array_name
    """
    self.send_bm_register_reset(cxt_id, register_array_name)
    self.recv_bm_register_reset()

  def send_bm_register_reset(self, cxt_id, register_array_name):
    self._oprot.writeMessageBegin('bm_register_reset', TMessageType.CALL, self._seqid)
    args = bm_register_reset_args()
    args.cxt_id = cxt_id
    args.register_array_name = register_array_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_register_reset(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_register_reset_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_parse_vset_add(self, cxt_id, parse_vset_name, value):
    """
    Parameters:
     - cxt_id
     - parse_vset_name
     - value
    """
    self.send_bm_parse_vset_add(cxt_id, parse_vset_name, value)
    self.recv_bm_parse_vset_add()

  def send_bm_parse_vset_add(self, cxt_id, parse_vset_name, value):
    self._oprot.writeMessageBegin('bm_parse_vset_add', TMessageType.CALL, self._seqid)
    args = bm_parse_vset_add_args()
    args.cxt_id = cxt_id
    args.parse_vset_name = parse_vset_name
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_parse_vset_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_parse_vset_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_parse_vset_remove(self, cxt_id, parse_vset_name, value):
    """
    Parameters:
     - cxt_id
     - parse_vset_name
     - value
    """
    self.send_bm_parse_vset_remove(cxt_id, parse_vset_name, value)
    self.recv_bm_parse_vset_remove()

  def send_bm_parse_vset_remove(self, cxt_id, parse_vset_name, value):
    self._oprot.writeMessageBegin('bm_parse_vset_remove', TMessageType.CALL, self._seqid)
    args = bm_parse_vset_remove_args()
    args.cxt_id = cxt_id
    args.parse_vset_name = parse_vset_name
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_parse_vset_remove(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_parse_vset_remove_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_dev_mgr_add_port(self, iface_name, port_num, pcap_path):
    """
    Parameters:
     - iface_name
     - port_num
     - pcap_path
    """
    self.send_bm_dev_mgr_add_port(iface_name, port_num, pcap_path)
    self.recv_bm_dev_mgr_add_port()

  def send_bm_dev_mgr_add_port(self, iface_name, port_num, pcap_path):
    self._oprot.writeMessageBegin('bm_dev_mgr_add_port', TMessageType.CALL, self._seqid)
    args = bm_dev_mgr_add_port_args()
    args.iface_name = iface_name
    args.port_num = port_num
    args.pcap_path = pcap_path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_dev_mgr_add_port(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_dev_mgr_add_port_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_dev_mgr_remove_port(self, port_num):
    """
    Parameters:
     - port_num
    """
    self.send_bm_dev_mgr_remove_port(port_num)
    self.recv_bm_dev_mgr_remove_port()

  def send_bm_dev_mgr_remove_port(self, port_num):
    self._oprot.writeMessageBegin('bm_dev_mgr_remove_port', TMessageType.CALL, self._seqid)
    args = bm_dev_mgr_remove_port_args()
    args.port_num = port_num
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_dev_mgr_remove_port(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_dev_mgr_remove_port_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_dev_mgr_show_ports(self):
    self.send_bm_dev_mgr_show_ports()
    return self.recv_bm_dev_mgr_show_ports()

  def send_bm_dev_mgr_show_ports(self):
    self._oprot.writeMessageBegin('bm_dev_mgr_show_ports', TMessageType.CALL, self._seqid)
    args = bm_dev_mgr_show_ports_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_dev_mgr_show_ports(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_dev_mgr_show_ports_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_dev_mgr_show_ports failed: unknown result");

  def bm_mgmt_get_info(self):
    self.send_bm_mgmt_get_info()
    return self.recv_bm_mgmt_get_info()

  def send_bm_mgmt_get_info(self):
    self._oprot.writeMessageBegin('bm_mgmt_get_info', TMessageType.CALL, self._seqid)
    args = bm_mgmt_get_info_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_mgmt_get_info(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_mgmt_get_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_mgmt_get_info failed: unknown result");

  def bm_set_crc16_custom_parameters(self, cxt_id, calc_name, crc16_config):
    """
    Parameters:
     - cxt_id
     - calc_name
     - crc16_config
    """
    self.send_bm_set_crc16_custom_parameters(cxt_id, calc_name, crc16_config)
    self.recv_bm_set_crc16_custom_parameters()

  def send_bm_set_crc16_custom_parameters(self, cxt_id, calc_name, crc16_config):
    self._oprot.writeMessageBegin('bm_set_crc16_custom_parameters', TMessageType.CALL, self._seqid)
    args = bm_set_crc16_custom_parameters_args()
    args.cxt_id = cxt_id
    args.calc_name = calc_name
    args.crc16_config = crc16_config
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_set_crc16_custom_parameters(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_set_crc16_custom_parameters_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_set_crc32_custom_parameters(self, cxt_id, calc_name, crc32_config):
    """
    Parameters:
     - cxt_id
     - calc_name
     - crc32_config
    """
    self.send_bm_set_crc32_custom_parameters(cxt_id, calc_name, crc32_config)
    self.recv_bm_set_crc32_custom_parameters()

  def send_bm_set_crc32_custom_parameters(self, cxt_id, calc_name, crc32_config):
    self._oprot.writeMessageBegin('bm_set_crc32_custom_parameters', TMessageType.CALL, self._seqid)
    args = bm_set_crc32_custom_parameters_args()
    args.cxt_id = cxt_id
    args.calc_name = calc_name
    args.crc32_config = crc32_config
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_set_crc32_custom_parameters(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_set_crc32_custom_parameters_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def bm_reset_state(self):
    self.send_bm_reset_state()
    self.recv_bm_reset_state()

  def send_bm_reset_state(self):
    self._oprot.writeMessageBegin('bm_reset_state', TMessageType.CALL, self._seqid)
    args = bm_reset_state_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_reset_state(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_reset_state_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return

  def bm_get_config(self):
    self.send_bm_get_config()
    return self.recv_bm_get_config()

  def send_bm_get_config(self):
    self._oprot.writeMessageBegin('bm_get_config', TMessageType.CALL, self._seqid)
    args = bm_get_config_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_get_config(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_get_config_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_get_config failed: unknown result");

  def bm_get_config_md5(self):
    self.send_bm_get_config_md5()
    return self.recv_bm_get_config_md5()

  def send_bm_get_config_md5(self):
    self._oprot.writeMessageBegin('bm_get_config_md5', TMessageType.CALL, self._seqid)
    args = bm_get_config_md5_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_get_config_md5(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_get_config_md5_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_get_config_md5 failed: unknown result");

  def bm_serialize_state(self):
    self.send_bm_serialize_state()
    return self.recv_bm_serialize_state()

  def send_bm_serialize_state(self):
    self._oprot.writeMessageBegin('bm_serialize_state', TMessageType.CALL, self._seqid)
    args = bm_serialize_state_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bm_serialize_state(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bm_serialize_state_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bm_serialize_state failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["bm_mt_get_num_entries"] = Processor.process_bm_mt_get_num_entries
    self._processMap["bm_mt_add_entry"] = Processor.process_bm_mt_add_entry
    self._processMap["bm_mt_set_default_action"] = Processor.process_bm_mt_set_default_action
    self._processMap["bm_mt_delete_entry"] = Processor.process_bm_mt_delete_entry
    self._processMap["bm_mt_modify_entry"] = Processor.process_bm_mt_modify_entry
    self._processMap["bm_mt_set_entry_ttl"] = Processor.process_bm_mt_set_entry_ttl
    self._processMap["bm_mt_indirect_add_member"] = Processor.process_bm_mt_indirect_add_member
    self._processMap["bm_mt_indirect_delete_member"] = Processor.process_bm_mt_indirect_delete_member
    self._processMap["bm_mt_indirect_modify_member"] = Processor.process_bm_mt_indirect_modify_member
    self._processMap["bm_mt_indirect_add_entry"] = Processor.process_bm_mt_indirect_add_entry
    self._processMap["bm_mt_indirect_modify_entry"] = Processor.process_bm_mt_indirect_modify_entry
    self._processMap["bm_mt_indirect_delete_entry"] = Processor.process_bm_mt_indirect_delete_entry
    self._processMap["bm_mt_indirect_set_entry_ttl"] = Processor.process_bm_mt_indirect_set_entry_ttl
    self._processMap["bm_mt_indirect_set_default_member"] = Processor.process_bm_mt_indirect_set_default_member
    self._processMap["bm_mt_indirect_ws_create_group"] = Processor.process_bm_mt_indirect_ws_create_group
    self._processMap["bm_mt_indirect_ws_delete_group"] = Processor.process_bm_mt_indirect_ws_delete_group
    self._processMap["bm_mt_indirect_ws_add_member_to_group"] = Processor.process_bm_mt_indirect_ws_add_member_to_group
    self._processMap["bm_mt_indirect_ws_remove_member_from_group"] = Processor.process_bm_mt_indirect_ws_remove_member_from_group
    self._processMap["bm_mt_indirect_ws_add_entry"] = Processor.process_bm_mt_indirect_ws_add_entry
    self._processMap["bm_mt_indirect_ws_modify_entry"] = Processor.process_bm_mt_indirect_ws_modify_entry
    self._processMap["bm_mt_indirect_ws_set_default_group"] = Processor.process_bm_mt_indirect_ws_set_default_group
    self._processMap["bm_mt_read_counter"] = Processor.process_bm_mt_read_counter
    self._processMap["bm_mt_reset_counters"] = Processor.process_bm_mt_reset_counters
    self._processMap["bm_mt_write_counter"] = Processor.process_bm_mt_write_counter
    self._processMap["bm_mt_set_meter_rates"] = Processor.process_bm_mt_set_meter_rates
    self._processMap["bm_mt_get_meter_rates"] = Processor.process_bm_mt_get_meter_rates
    self._processMap["bm_mt_get_entries"] = Processor.process_bm_mt_get_entries
    self._processMap["bm_mt_get_entry"] = Processor.process_bm_mt_get_entry
    self._processMap["bm_mt_get_default_entry"] = Processor.process_bm_mt_get_default_entry
    self._processMap["bm_mt_get_entry_from_key"] = Processor.process_bm_mt_get_entry_from_key
    self._processMap["bm_mt_indirect_get_members"] = Processor.process_bm_mt_indirect_get_members
    self._processMap["bm_mt_indirect_get_member"] = Processor.process_bm_mt_indirect_get_member
    self._processMap["bm_mt_indirect_ws_get_groups"] = Processor.process_bm_mt_indirect_ws_get_groups
    self._processMap["bm_mt_indirect_ws_get_group"] = Processor.process_bm_mt_indirect_ws_get_group
    self._processMap["bm_counter_read"] = Processor.process_bm_counter_read
    self._processMap["bm_counter_reset_all"] = Processor.process_bm_counter_reset_all
    self._processMap["bm_counter_write"] = Processor.process_bm_counter_write
    self._processMap["bm_learning_ack"] = Processor.process_bm_learning_ack
    self._processMap["bm_learning_ack_buffer"] = Processor.process_bm_learning_ack_buffer
    self._processMap["bm_learning_set_timeout"] = Processor.process_bm_learning_set_timeout
    self._processMap["bm_learning_set_buffer_size"] = Processor.process_bm_learning_set_buffer_size
    self._processMap["bm_load_new_config"] = Processor.process_bm_load_new_config
    self._processMap["bm_swap_configs"] = Processor.process_bm_swap_configs
    self._processMap["bm_meter_array_set_rates"] = Processor.process_bm_meter_array_set_rates
    self._processMap["bm_meter_set_rates"] = Processor.process_bm_meter_set_rates
    self._processMap["bm_meter_get_rates"] = Processor.process_bm_meter_get_rates
    self._processMap["bm_register_read"] = Processor.process_bm_register_read
    self._processMap["bm_register_write"] = Processor.process_bm_register_write
    self._processMap["bm_register_write_range"] = Processor.process_bm_register_write_range
    self._processMap["bm_register_reset"] = Processor.process_bm_register_reset
    self._processMap["bm_parse_vset_add"] = Processor.process_bm_parse_vset_add
    self._processMap["bm_parse_vset_remove"] = Processor.process_bm_parse_vset_remove
    self._processMap["bm_dev_mgr_add_port"] = Processor.process_bm_dev_mgr_add_port
    self._processMap["bm_dev_mgr_remove_port"] = Processor.process_bm_dev_mgr_remove_port
    self._processMap["bm_dev_mgr_show_ports"] = Processor.process_bm_dev_mgr_show_ports
    self._processMap["bm_mgmt_get_info"] = Processor.process_bm_mgmt_get_info
    self._processMap["bm_set_crc16_custom_parameters"] = Processor.process_bm_set_crc16_custom_parameters
    self._processMap["bm_set_crc32_custom_parameters"] = Processor.process_bm_set_crc32_custom_parameters
    self._processMap["bm_reset_state"] = Processor.process_bm_reset_state
    self._processMap["bm_get_config"] = Processor.process_bm_get_config
    self._processMap["bm_get_config_md5"] = Processor.process_bm_get_config_md5
    self._processMap["bm_serialize_state"] = Processor.process_bm_serialize_state

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_bm_mt_get_num_entries(self, seqid, iprot, oprot):
    args = bm_mt_get_num_entries_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_get_num_entries_result()
    try:
      result.success = self._handler.bm_mt_get_num_entries(args.cxt_id, args.table_name)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_get_num_entries", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_add_entry(self, seqid, iprot, oprot):
    args = bm_mt_add_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_add_entry_result()
    try:
      result.success = self._handler.bm_mt_add_entry(args.cxt_id, args.table_name, args.match_key, args.action_name, args.action_data, args.options)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_add_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_set_default_action(self, seqid, iprot, oprot):
    args = bm_mt_set_default_action_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_set_default_action_result()
    try:
      self._handler.bm_mt_set_default_action(args.cxt_id, args.table_name, args.action_name, args.action_data)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_set_default_action", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_delete_entry(self, seqid, iprot, oprot):
    args = bm_mt_delete_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_delete_entry_result()
    try:
      self._handler.bm_mt_delete_entry(args.cxt_id, args.table_name, args.entry_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_delete_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_modify_entry(self, seqid, iprot, oprot):
    args = bm_mt_modify_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_modify_entry_result()
    try:
      self._handler.bm_mt_modify_entry(args.cxt_id, args.table_name, args.entry_handle, args.action_name, args.action_data)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_modify_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_set_entry_ttl(self, seqid, iprot, oprot):
    args = bm_mt_set_entry_ttl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_set_entry_ttl_result()
    try:
      self._handler.bm_mt_set_entry_ttl(args.cxt_id, args.table_name, args.entry_handle, args.timeout_ms)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_set_entry_ttl", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_add_member(self, seqid, iprot, oprot):
    args = bm_mt_indirect_add_member_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_add_member_result()
    try:
      result.success = self._handler.bm_mt_indirect_add_member(args.cxt_id, args.table_name, args.action_name, args.action_data)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_add_member", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_delete_member(self, seqid, iprot, oprot):
    args = bm_mt_indirect_delete_member_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_delete_member_result()
    try:
      self._handler.bm_mt_indirect_delete_member(args.cxt_id, args.table_name, args.mbr_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_delete_member", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_modify_member(self, seqid, iprot, oprot):
    args = bm_mt_indirect_modify_member_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_modify_member_result()
    try:
      self._handler.bm_mt_indirect_modify_member(args.cxt_id, args.table_name, args.mbr_handle, args.action_name, args.action_data)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_modify_member", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_add_entry(self, seqid, iprot, oprot):
    args = bm_mt_indirect_add_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_add_entry_result()
    try:
      result.success = self._handler.bm_mt_indirect_add_entry(args.cxt_id, args.table_name, args.match_key, args.mbr_handle, args.options)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_add_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_modify_entry(self, seqid, iprot, oprot):
    args = bm_mt_indirect_modify_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_modify_entry_result()
    try:
      self._handler.bm_mt_indirect_modify_entry(args.cxt_id, args.table_name, args.entry_handle, args.mbr_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_modify_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_delete_entry(self, seqid, iprot, oprot):
    args = bm_mt_indirect_delete_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_delete_entry_result()
    try:
      self._handler.bm_mt_indirect_delete_entry(args.cxt_id, args.table_name, args.entry_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_delete_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_set_entry_ttl(self, seqid, iprot, oprot):
    args = bm_mt_indirect_set_entry_ttl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_set_entry_ttl_result()
    try:
      self._handler.bm_mt_indirect_set_entry_ttl(args.cxt_id, args.table_name, args.entry_handle, args.timeout_ms)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_set_entry_ttl", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_set_default_member(self, seqid, iprot, oprot):
    args = bm_mt_indirect_set_default_member_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_set_default_member_result()
    try:
      self._handler.bm_mt_indirect_set_default_member(args.cxt_id, args.table_name, args.mbr_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_set_default_member", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_ws_create_group(self, seqid, iprot, oprot):
    args = bm_mt_indirect_ws_create_group_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_ws_create_group_result()
    try:
      result.success = self._handler.bm_mt_indirect_ws_create_group(args.cxt_id, args.table_name)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_ws_create_group", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_ws_delete_group(self, seqid, iprot, oprot):
    args = bm_mt_indirect_ws_delete_group_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_ws_delete_group_result()
    try:
      self._handler.bm_mt_indirect_ws_delete_group(args.cxt_id, args.table_name, args.grp_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_ws_delete_group", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_ws_add_member_to_group(self, seqid, iprot, oprot):
    args = bm_mt_indirect_ws_add_member_to_group_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_ws_add_member_to_group_result()
    try:
      self._handler.bm_mt_indirect_ws_add_member_to_group(args.cxt_id, args.table_name, args.mbr_handle, args.grp_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_ws_add_member_to_group", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_ws_remove_member_from_group(self, seqid, iprot, oprot):
    args = bm_mt_indirect_ws_remove_member_from_group_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_ws_remove_member_from_group_result()
    try:
      self._handler.bm_mt_indirect_ws_remove_member_from_group(args.cxt_id, args.table_name, args.mbr_handle, args.grp_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_ws_remove_member_from_group", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_ws_add_entry(self, seqid, iprot, oprot):
    args = bm_mt_indirect_ws_add_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_ws_add_entry_result()
    try:
      result.success = self._handler.bm_mt_indirect_ws_add_entry(args.cxt_id, args.table_name, args.match_key, args.grp_handle, args.options)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_ws_add_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_ws_modify_entry(self, seqid, iprot, oprot):
    args = bm_mt_indirect_ws_modify_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_ws_modify_entry_result()
    try:
      self._handler.bm_mt_indirect_ws_modify_entry(args.cxt_id, args.table_name, args.entry_handle, args.grp_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_ws_modify_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_ws_set_default_group(self, seqid, iprot, oprot):
    args = bm_mt_indirect_ws_set_default_group_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_ws_set_default_group_result()
    try:
      self._handler.bm_mt_indirect_ws_set_default_group(args.cxt_id, args.table_name, args.grp_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_ws_set_default_group", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_read_counter(self, seqid, iprot, oprot):
    args = bm_mt_read_counter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_read_counter_result()
    try:
      result.success = self._handler.bm_mt_read_counter(args.cxt_id, args.table_name, args.entry_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_read_counter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_reset_counters(self, seqid, iprot, oprot):
    args = bm_mt_reset_counters_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_reset_counters_result()
    try:
      self._handler.bm_mt_reset_counters(args.cxt_id, args.table_name)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_reset_counters", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_write_counter(self, seqid, iprot, oprot):
    args = bm_mt_write_counter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_write_counter_result()
    try:
      self._handler.bm_mt_write_counter(args.cxt_id, args.table_name, args.entry_handle, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_write_counter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_set_meter_rates(self, seqid, iprot, oprot):
    args = bm_mt_set_meter_rates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_set_meter_rates_result()
    try:
      self._handler.bm_mt_set_meter_rates(args.cxt_id, args.table_name, args.entry_handle, args.rates)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_set_meter_rates", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_get_meter_rates(self, seqid, iprot, oprot):
    args = bm_mt_get_meter_rates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_get_meter_rates_result()
    try:
      result.success = self._handler.bm_mt_get_meter_rates(args.cxt_id, args.table_name, args.entry_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_get_meter_rates", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_get_entries(self, seqid, iprot, oprot):
    args = bm_mt_get_entries_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_get_entries_result()
    try:
      result.success = self._handler.bm_mt_get_entries(args.cxt_id, args.table_name)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_get_entries", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_get_entry(self, seqid, iprot, oprot):
    args = bm_mt_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_get_entry_result()
    try:
      result.success = self._handler.bm_mt_get_entry(args.cxt_id, args.table_name, args.entry_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_get_default_entry(self, seqid, iprot, oprot):
    args = bm_mt_get_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_get_default_entry_result()
    try:
      result.success = self._handler.bm_mt_get_default_entry(args.cxt_id, args.table_name)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_get_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_get_entry_from_key(self, seqid, iprot, oprot):
    args = bm_mt_get_entry_from_key_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_get_entry_from_key_result()
    try:
      result.success = self._handler.bm_mt_get_entry_from_key(args.cxt_id, args.table_name, args.match_key, args.options)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_get_entry_from_key", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_get_members(self, seqid, iprot, oprot):
    args = bm_mt_indirect_get_members_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_get_members_result()
    try:
      result.success = self._handler.bm_mt_indirect_get_members(args.cxt_id, args.table_name)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_get_members", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_get_member(self, seqid, iprot, oprot):
    args = bm_mt_indirect_get_member_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_get_member_result()
    try:
      result.success = self._handler.bm_mt_indirect_get_member(args.cxt_id, args.table_name, args.mbr_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_get_member", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_ws_get_groups(self, seqid, iprot, oprot):
    args = bm_mt_indirect_ws_get_groups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_ws_get_groups_result()
    try:
      result.success = self._handler.bm_mt_indirect_ws_get_groups(args.cxt_id, args.table_name)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_ws_get_groups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mt_indirect_ws_get_group(self, seqid, iprot, oprot):
    args = bm_mt_indirect_ws_get_group_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mt_indirect_ws_get_group_result()
    try:
      result.success = self._handler.bm_mt_indirect_ws_get_group(args.cxt_id, args.table_name, args.grp_handle)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_mt_indirect_ws_get_group", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_counter_read(self, seqid, iprot, oprot):
    args = bm_counter_read_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_counter_read_result()
    try:
      result.success = self._handler.bm_counter_read(args.cxt_id, args.counter_name, args.index)
    except InvalidCounterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_counter_read", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_counter_reset_all(self, seqid, iprot, oprot):
    args = bm_counter_reset_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_counter_reset_all_result()
    try:
      self._handler.bm_counter_reset_all(args.cxt_id, args.counter_name)
    except InvalidCounterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_counter_reset_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_counter_write(self, seqid, iprot, oprot):
    args = bm_counter_write_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_counter_write_result()
    try:
      self._handler.bm_counter_write(args.cxt_id, args.counter_name, args.index, args.value)
    except InvalidCounterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_counter_write", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_learning_ack(self, seqid, iprot, oprot):
    args = bm_learning_ack_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_learning_ack_result()
    try:
      self._handler.bm_learning_ack(args.cxt_id, args.list_id, args.buffer_id, args.sample_ids)
    except InvalidLearnOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_learning_ack", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_learning_ack_buffer(self, seqid, iprot, oprot):
    args = bm_learning_ack_buffer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_learning_ack_buffer_result()
    try:
      self._handler.bm_learning_ack_buffer(args.cxt_id, args.list_id, args.buffer_id)
    except InvalidLearnOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_learning_ack_buffer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_learning_set_timeout(self, seqid, iprot, oprot):
    args = bm_learning_set_timeout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_learning_set_timeout_result()
    try:
      self._handler.bm_learning_set_timeout(args.cxt_id, args.list_id, args.timeout_ms)
    except InvalidLearnOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_learning_set_timeout", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_learning_set_buffer_size(self, seqid, iprot, oprot):
    args = bm_learning_set_buffer_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_learning_set_buffer_size_result()
    try:
      self._handler.bm_learning_set_buffer_size(args.cxt_id, args.list_id, args.nb_samples)
    except InvalidLearnOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_learning_set_buffer_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_load_new_config(self, seqid, iprot, oprot):
    args = bm_load_new_config_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_load_new_config_result()
    try:
      self._handler.bm_load_new_config(args.config_str)
    except InvalidSwapOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_load_new_config", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_swap_configs(self, seqid, iprot, oprot):
    args = bm_swap_configs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_swap_configs_result()
    try:
      self._handler.bm_swap_configs()
    except InvalidSwapOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_swap_configs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_meter_array_set_rates(self, seqid, iprot, oprot):
    args = bm_meter_array_set_rates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_meter_array_set_rates_result()
    try:
      self._handler.bm_meter_array_set_rates(args.cxt_id, args.meter_array_name, args.rates)
    except InvalidMeterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_meter_array_set_rates", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_meter_set_rates(self, seqid, iprot, oprot):
    args = bm_meter_set_rates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_meter_set_rates_result()
    try:
      self._handler.bm_meter_set_rates(args.cxt_id, args.meter_array_name, args.index, args.rates)
    except InvalidMeterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_meter_set_rates", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_meter_get_rates(self, seqid, iprot, oprot):
    args = bm_meter_get_rates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_meter_get_rates_result()
    try:
      result.success = self._handler.bm_meter_get_rates(args.cxt_id, args.meter_array_name, args.index)
    except InvalidMeterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_meter_get_rates", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_register_read(self, seqid, iprot, oprot):
    args = bm_register_read_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_register_read_result()
    try:
      result.success = self._handler.bm_register_read(args.cxt_id, args.register_array_name, args.idx)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_register_read", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_register_write(self, seqid, iprot, oprot):
    args = bm_register_write_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_register_write_result()
    try:
      self._handler.bm_register_write(args.cxt_id, args.register_array_name, args.index, args.value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_register_write", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_register_write_range(self, seqid, iprot, oprot):
    args = bm_register_write_range_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_register_write_range_result()
    try:
      self._handler.bm_register_write_range(args.cxt_id, args.register_array_name, args.start_index, args.end_index, args.value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_register_write_range", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_register_reset(self, seqid, iprot, oprot):
    args = bm_register_reset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_register_reset_result()
    try:
      self._handler.bm_register_reset(args.cxt_id, args.register_array_name)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_register_reset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_parse_vset_add(self, seqid, iprot, oprot):
    args = bm_parse_vset_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_parse_vset_add_result()
    try:
      self._handler.bm_parse_vset_add(args.cxt_id, args.parse_vset_name, args.value)
    except InvalidParseVSetOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_parse_vset_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_parse_vset_remove(self, seqid, iprot, oprot):
    args = bm_parse_vset_remove_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_parse_vset_remove_result()
    try:
      self._handler.bm_parse_vset_remove(args.cxt_id, args.parse_vset_name, args.value)
    except InvalidParseVSetOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_parse_vset_remove", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_dev_mgr_add_port(self, seqid, iprot, oprot):
    args = bm_dev_mgr_add_port_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_dev_mgr_add_port_result()
    try:
      self._handler.bm_dev_mgr_add_port(args.iface_name, args.port_num, args.pcap_path)
    except InvalidDevMgrOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_dev_mgr_add_port", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_dev_mgr_remove_port(self, seqid, iprot, oprot):
    args = bm_dev_mgr_remove_port_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_dev_mgr_remove_port_result()
    try:
      self._handler.bm_dev_mgr_remove_port(args.port_num)
    except InvalidDevMgrOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_dev_mgr_remove_port", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_dev_mgr_show_ports(self, seqid, iprot, oprot):
    args = bm_dev_mgr_show_ports_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_dev_mgr_show_ports_result()
    try:
      result.success = self._handler.bm_dev_mgr_show_ports()
    except InvalidDevMgrOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_dev_mgr_show_ports", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_mgmt_get_info(self, seqid, iprot, oprot):
    args = bm_mgmt_get_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_mgmt_get_info_result()
    result.success = self._handler.bm_mgmt_get_info()
    oprot.writeMessageBegin("bm_mgmt_get_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_set_crc16_custom_parameters(self, seqid, iprot, oprot):
    args = bm_set_crc16_custom_parameters_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_set_crc16_custom_parameters_result()
    try:
      self._handler.bm_set_crc16_custom_parameters(args.cxt_id, args.calc_name, args.crc16_config)
    except InvalidCrcOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_set_crc16_custom_parameters", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_set_crc32_custom_parameters(self, seqid, iprot, oprot):
    args = bm_set_crc32_custom_parameters_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_set_crc32_custom_parameters_result()
    try:
      self._handler.bm_set_crc32_custom_parameters(args.cxt_id, args.calc_name, args.crc32_config)
    except InvalidCrcOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("bm_set_crc32_custom_parameters", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_reset_state(self, seqid, iprot, oprot):
    args = bm_reset_state_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_reset_state_result()
    self._handler.bm_reset_state()
    oprot.writeMessageBegin("bm_reset_state", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_get_config(self, seqid, iprot, oprot):
    args = bm_get_config_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_get_config_result()
    result.success = self._handler.bm_get_config()
    oprot.writeMessageBegin("bm_get_config", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_get_config_md5(self, seqid, iprot, oprot):
    args = bm_get_config_md5_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_get_config_md5_result()
    result.success = self._handler.bm_get_config_md5()
    oprot.writeMessageBegin("bm_get_config_md5", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bm_serialize_state(self, seqid, iprot, oprot):
    args = bm_serialize_state_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bm_serialize_state_result()
    result.success = self._handler.bm_serialize_state()
    oprot.writeMessageBegin("bm_serialize_state", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class bm_mt_get_num_entries_args:
  """
  Attributes:
   - cxt_id
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, cxt_id=None, table_name=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_num_entries_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_num_entries_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_num_entries_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_add_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - match_key
   - action_name
   - action_data
   - options
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.LIST, 'match_key', (TType.STRUCT,(BmMatchParam, BmMatchParam.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'action_name', None, None, ), # 4
    (5, TType.LIST, 'action_data', (TType.STRING,None), None, ), # 5
    (6, TType.STRUCT, 'options', (BmAddEntryOptions, BmAddEntryOptions.thrift_spec), None, ), # 6
  )

  def __init__(self, cxt_id=None, table_name=None, match_key=None, action_name=None, action_data=None, options=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.match_key = match_key
    self.action_name = action_name
    self.action_data = action_data
    self.options = options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.match_key = []
          (_etype40, _size37) = iprot.readListBegin()
          for _i41 in xrange(_size37):
            _elem42 = BmMatchParam()
            _elem42.read(iprot)
            self.match_key.append(_elem42)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.action_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.action_data = []
          (_etype46, _size43) = iprot.readListBegin()
          for _i47 in xrange(_size43):
            _elem48 = iprot.readString();
            self.action_data.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.options = BmAddEntryOptions()
          self.options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_add_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.match_key is not None:
      oprot.writeFieldBegin('match_key', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.match_key))
      for iter49 in self.match_key:
        iter49.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.action_name is not None:
      oprot.writeFieldBegin('action_name', TType.STRING, 4)
      oprot.writeString(self.action_name)
      oprot.writeFieldEnd()
    if self.action_data is not None:
      oprot.writeFieldBegin('action_data', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.action_data))
      for iter50 in self.action_data:
        oprot.writeString(iter50)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.options is not None:
      oprot.writeFieldBegin('options', TType.STRUCT, 6)
      self.options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.match_key)
    value = (value * 31) ^ hash(self.action_name)
    value = (value * 31) ^ hash(self.action_data)
    value = (value * 31) ^ hash(self.options)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_add_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_add_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_set_default_action_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - action_name
   - action_data
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'action_name', None, None, ), # 3
    (4, TType.LIST, 'action_data', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, action_name=None, action_data=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.action_name = action_name
    self.action_data = action_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.action_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.action_data = []
          (_etype54, _size51) = iprot.readListBegin()
          for _i55 in xrange(_size51):
            _elem56 = iprot.readString();
            self.action_data.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_set_default_action_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.action_name is not None:
      oprot.writeFieldBegin('action_name', TType.STRING, 3)
      oprot.writeString(self.action_name)
      oprot.writeFieldEnd()
    if self.action_data is not None:
      oprot.writeFieldBegin('action_data', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.action_data))
      for iter57 in self.action_data:
        oprot.writeString(iter57)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.action_name)
    value = (value * 31) ^ hash(self.action_data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_set_default_action_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_set_default_action_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_delete_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_delete_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_delete_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_delete_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_modify_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
   - action_name
   - action_data
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
    (4, TType.STRING, 'action_name', None, None, ), # 4
    (5, TType.LIST, 'action_data', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None, action_name=None, action_data=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle
    self.action_name = action_name
    self.action_data = action_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.action_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.action_data = []
          (_etype61, _size58) = iprot.readListBegin()
          for _i62 in xrange(_size58):
            _elem63 = iprot.readString();
            self.action_data.append(_elem63)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_modify_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    if self.action_name is not None:
      oprot.writeFieldBegin('action_name', TType.STRING, 4)
      oprot.writeString(self.action_name)
      oprot.writeFieldEnd()
    if self.action_data is not None:
      oprot.writeFieldBegin('action_data', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.action_data))
      for iter64 in self.action_data:
        oprot.writeString(iter64)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    value = (value * 31) ^ hash(self.action_name)
    value = (value * 31) ^ hash(self.action_data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_modify_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_modify_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_set_entry_ttl_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
   - timeout_ms
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
    (4, TType.I32, 'timeout_ms', None, None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None, timeout_ms=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle
    self.timeout_ms = timeout_ms

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.timeout_ms = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_set_entry_ttl_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    if self.timeout_ms is not None:
      oprot.writeFieldBegin('timeout_ms', TType.I32, 4)
      oprot.writeI32(self.timeout_ms)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    value = (value * 31) ^ hash(self.timeout_ms)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_set_entry_ttl_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_set_entry_ttl_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_add_member_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - action_name
   - action_data
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'action_name', None, None, ), # 3
    (4, TType.LIST, 'action_data', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, action_name=None, action_data=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.action_name = action_name
    self.action_data = action_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.action_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.action_data = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = iprot.readString();
            self.action_data.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_add_member_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.action_name is not None:
      oprot.writeFieldBegin('action_name', TType.STRING, 3)
      oprot.writeString(self.action_name)
      oprot.writeFieldEnd()
    if self.action_data is not None:
      oprot.writeFieldBegin('action_data', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.action_data))
      for iter71 in self.action_data:
        oprot.writeString(iter71)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.action_name)
    value = (value * 31) ^ hash(self.action_data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_add_member_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_add_member_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_delete_member_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - mbr_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'mbr_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, mbr_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.mbr_handle = mbr_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_delete_member_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 3)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.mbr_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_delete_member_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_delete_member_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_modify_member_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - mbr_handle
   - action_name
   - action_data
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'mbr_handle', None, None, ), # 3
    (4, TType.STRING, 'action_name', None, None, ), # 4
    (5, TType.LIST, 'action_data', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, cxt_id=None, table_name=None, mbr_handle=None, action_name=None, action_data=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.mbr_handle = mbr_handle
    self.action_name = action_name
    self.action_data = action_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.action_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.action_data = []
          (_etype75, _size72) = iprot.readListBegin()
          for _i76 in xrange(_size72):
            _elem77 = iprot.readString();
            self.action_data.append(_elem77)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_modify_member_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 3)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    if self.action_name is not None:
      oprot.writeFieldBegin('action_name', TType.STRING, 4)
      oprot.writeString(self.action_name)
      oprot.writeFieldEnd()
    if self.action_data is not None:
      oprot.writeFieldBegin('action_data', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.action_data))
      for iter78 in self.action_data:
        oprot.writeString(iter78)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.mbr_handle)
    value = (value * 31) ^ hash(self.action_name)
    value = (value * 31) ^ hash(self.action_data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_modify_member_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_modify_member_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_add_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - match_key
   - mbr_handle
   - options
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.LIST, 'match_key', (TType.STRUCT,(BmMatchParam, BmMatchParam.thrift_spec)), None, ), # 3
    (4, TType.I32, 'mbr_handle', None, None, ), # 4
    (5, TType.STRUCT, 'options', (BmAddEntryOptions, BmAddEntryOptions.thrift_spec), None, ), # 5
  )

  def __init__(self, cxt_id=None, table_name=None, match_key=None, mbr_handle=None, options=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.match_key = match_key
    self.mbr_handle = mbr_handle
    self.options = options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.match_key = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = BmMatchParam()
            _elem84.read(iprot)
            self.match_key.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.options = BmAddEntryOptions()
          self.options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_add_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.match_key is not None:
      oprot.writeFieldBegin('match_key', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.match_key))
      for iter85 in self.match_key:
        iter85.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 4)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    if self.options is not None:
      oprot.writeFieldBegin('options', TType.STRUCT, 5)
      self.options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.match_key)
    value = (value * 31) ^ hash(self.mbr_handle)
    value = (value * 31) ^ hash(self.options)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_add_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_add_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_modify_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
   - mbr_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
    (4, TType.I32, 'mbr_handle', None, None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None, mbr_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle
    self.mbr_handle = mbr_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_modify_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 4)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    value = (value * 31) ^ hash(self.mbr_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_modify_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_modify_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_delete_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_delete_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_delete_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_delete_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_set_entry_ttl_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
   - timeout_ms
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
    (4, TType.I32, 'timeout_ms', None, None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None, timeout_ms=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle
    self.timeout_ms = timeout_ms

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.timeout_ms = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_set_entry_ttl_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    if self.timeout_ms is not None:
      oprot.writeFieldBegin('timeout_ms', TType.I32, 4)
      oprot.writeI32(self.timeout_ms)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    value = (value * 31) ^ hash(self.timeout_ms)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_set_entry_ttl_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_set_entry_ttl_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_set_default_member_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - mbr_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'mbr_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, mbr_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.mbr_handle = mbr_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_set_default_member_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 3)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.mbr_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_set_default_member_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_set_default_member_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_create_group_args:
  """
  Attributes:
   - cxt_id
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, cxt_id=None, table_name=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_create_group_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_create_group_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_create_group_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_delete_group_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - grp_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'grp_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, grp_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.grp_handle = grp_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.grp_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_delete_group_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.grp_handle is not None:
      oprot.writeFieldBegin('grp_handle', TType.I32, 3)
      oprot.writeI32(self.grp_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.grp_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_delete_group_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_delete_group_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_add_member_to_group_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - mbr_handle
   - grp_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'mbr_handle', None, None, ), # 3
    (4, TType.I32, 'grp_handle', None, None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, mbr_handle=None, grp_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.mbr_handle = mbr_handle
    self.grp_handle = grp_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grp_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_add_member_to_group_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 3)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    if self.grp_handle is not None:
      oprot.writeFieldBegin('grp_handle', TType.I32, 4)
      oprot.writeI32(self.grp_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.mbr_handle)
    value = (value * 31) ^ hash(self.grp_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_add_member_to_group_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_add_member_to_group_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_remove_member_from_group_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - mbr_handle
   - grp_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'mbr_handle', None, None, ), # 3
    (4, TType.I32, 'grp_handle', None, None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, mbr_handle=None, grp_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.mbr_handle = mbr_handle
    self.grp_handle = grp_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grp_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_remove_member_from_group_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 3)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    if self.grp_handle is not None:
      oprot.writeFieldBegin('grp_handle', TType.I32, 4)
      oprot.writeI32(self.grp_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.mbr_handle)
    value = (value * 31) ^ hash(self.grp_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_remove_member_from_group_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_remove_member_from_group_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_add_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - match_key
   - grp_handle
   - options
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.LIST, 'match_key', (TType.STRUCT,(BmMatchParam, BmMatchParam.thrift_spec)), None, ), # 3
    (4, TType.I32, 'grp_handle', None, None, ), # 4
    (5, TType.STRUCT, 'options', (BmAddEntryOptions, BmAddEntryOptions.thrift_spec), None, ), # 5
  )

  def __init__(self, cxt_id=None, table_name=None, match_key=None, grp_handle=None, options=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.match_key = match_key
    self.grp_handle = grp_handle
    self.options = options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.match_key = []
          (_etype89, _size86) = iprot.readListBegin()
          for _i90 in xrange(_size86):
            _elem91 = BmMatchParam()
            _elem91.read(iprot)
            self.match_key.append(_elem91)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grp_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.options = BmAddEntryOptions()
          self.options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_add_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.match_key is not None:
      oprot.writeFieldBegin('match_key', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.match_key))
      for iter92 in self.match_key:
        iter92.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.grp_handle is not None:
      oprot.writeFieldBegin('grp_handle', TType.I32, 4)
      oprot.writeI32(self.grp_handle)
      oprot.writeFieldEnd()
    if self.options is not None:
      oprot.writeFieldBegin('options', TType.STRUCT, 5)
      self.options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.match_key)
    value = (value * 31) ^ hash(self.grp_handle)
    value = (value * 31) ^ hash(self.options)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_add_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_add_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_modify_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
   - grp_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
    (4, TType.I32, 'grp_handle', None, None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None, grp_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle
    self.grp_handle = grp_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grp_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_modify_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    if self.grp_handle is not None:
      oprot.writeFieldBegin('grp_handle', TType.I32, 4)
      oprot.writeI32(self.grp_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    value = (value * 31) ^ hash(self.grp_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_modify_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_modify_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_set_default_group_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - grp_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'grp_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, grp_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.grp_handle = grp_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.grp_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_set_default_group_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.grp_handle is not None:
      oprot.writeFieldBegin('grp_handle', TType.I32, 3)
      oprot.writeI32(self.grp_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.grp_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_set_default_group_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_set_default_group_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_read_counter_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_read_counter_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_read_counter_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BmCounterValue, BmCounterValue.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BmCounterValue()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_read_counter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_reset_counters_args:
  """
  Attributes:
   - cxt_id
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, cxt_id=None, table_name=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_reset_counters_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_reset_counters_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_reset_counters_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_write_counter_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
    (4, TType.STRUCT, 'value', (BmCounterValue, BmCounterValue.thrift_spec), None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None, value=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.value = BmCounterValue()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_write_counter_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 4)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_write_counter_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_write_counter_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_set_meter_rates_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
   - rates
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
    (4, TType.LIST, 'rates', (TType.STRUCT,(BmMeterRateConfig, BmMeterRateConfig.thrift_spec)), None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None, rates=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle
    self.rates = rates

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.rates = []
          (_etype96, _size93) = iprot.readListBegin()
          for _i97 in xrange(_size93):
            _elem98 = BmMeterRateConfig()
            _elem98.read(iprot)
            self.rates.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_set_meter_rates_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    if self.rates is not None:
      oprot.writeFieldBegin('rates', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.rates))
      for iter99 in self.rates:
        iter99.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    value = (value * 31) ^ hash(self.rates)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_set_meter_rates_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_set_meter_rates_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_meter_rates_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_meter_rates_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_meter_rates_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(BmMeterRateConfig, BmMeterRateConfig.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype103, _size100) = iprot.readListBegin()
          for _i104 in xrange(_size100):
            _elem105 = BmMeterRateConfig()
            _elem105.read(iprot)
            self.success.append(_elem105)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_meter_rates_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter106 in self.success:
        iter106.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_entries_args:
  """
  Attributes:
   - cxt_id
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, cxt_id=None, table_name=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_entries_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_entries_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(BmMtEntry, BmMtEntry.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = BmMtEntry()
            _elem112.read(iprot)
            self.success.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_entries_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter113 in self.success:
        iter113.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - entry_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, entry_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.entry_handle = entry_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.entry_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BmMtEntry, BmMtEntry.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BmMtEntry()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_default_entry_args:
  """
  Attributes:
   - cxt_id
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, cxt_id=None, table_name=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_default_entry_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_default_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BmActionEntry, BmActionEntry.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BmActionEntry()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_default_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_entry_from_key_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - match_key
   - options
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.LIST, 'match_key', (TType.STRUCT,(BmMatchParam, BmMatchParam.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'options', (BmAddEntryOptions, BmAddEntryOptions.thrift_spec), None, ), # 4
  )

  def __init__(self, cxt_id=None, table_name=None, match_key=None, options=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.match_key = match_key
    self.options = options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.match_key = []
          (_etype117, _size114) = iprot.readListBegin()
          for _i118 in xrange(_size114):
            _elem119 = BmMatchParam()
            _elem119.read(iprot)
            self.match_key.append(_elem119)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.options = BmAddEntryOptions()
          self.options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_entry_from_key_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.match_key is not None:
      oprot.writeFieldBegin('match_key', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.match_key))
      for iter120 in self.match_key:
        iter120.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.options is not None:
      oprot.writeFieldBegin('options', TType.STRUCT, 4)
      self.options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.match_key)
    value = (value * 31) ^ hash(self.options)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_get_entry_from_key_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BmMtEntry, BmMtEntry.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BmMtEntry()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_get_entry_from_key_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_get_members_args:
  """
  Attributes:
   - cxt_id
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, cxt_id=None, table_name=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_get_members_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_get_members_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(BmMtIndirectMember, BmMtIndirectMember.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype124, _size121) = iprot.readListBegin()
          for _i125 in xrange(_size121):
            _elem126 = BmMtIndirectMember()
            _elem126.read(iprot)
            self.success.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_get_members_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter127 in self.success:
        iter127.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_get_member_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - mbr_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'mbr_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, mbr_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.mbr_handle = mbr_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_get_member_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 3)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.mbr_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_get_member_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BmMtIndirectMember, BmMtIndirectMember.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BmMtIndirectMember()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_get_member_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_get_groups_args:
  """
  Attributes:
   - cxt_id
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, cxt_id=None, table_name=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_get_groups_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_get_groups_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(BmMtIndirectWsGroup, BmMtIndirectWsGroup.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype131, _size128) = iprot.readListBegin()
          for _i132 in xrange(_size128):
            _elem133 = BmMtIndirectWsGroup()
            _elem133.read(iprot)
            self.success.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_get_groups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter134 in self.success:
        iter134.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_get_group_args:
  """
  Attributes:
   - cxt_id
   - table_name
   - grp_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'grp_handle', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, table_name=None, grp_handle=None,):
    self.cxt_id = cxt_id
    self.table_name = table_name
    self.grp_handle = grp_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.grp_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_get_group_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.grp_handle is not None:
      oprot.writeFieldBegin('grp_handle', TType.I32, 3)
      oprot.writeI32(self.grp_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.grp_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mt_indirect_ws_get_group_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BmMtIndirectWsGroup, BmMtIndirectWsGroup.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BmMtIndirectWsGroup()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mt_indirect_ws_get_group_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_counter_read_args:
  """
  Attributes:
   - cxt_id
   - counter_name
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'counter_name', None, None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, counter_name=None, index=None,):
    self.cxt_id = cxt_id
    self.counter_name = counter_name
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.counter_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_counter_read_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.counter_name is not None:
      oprot.writeFieldBegin('counter_name', TType.STRING, 2)
      oprot.writeString(self.counter_name)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.counter_name)
    value = (value * 31) ^ hash(self.index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_counter_read_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BmCounterValue, BmCounterValue.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidCounterOperation, InvalidCounterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BmCounterValue()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidCounterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_counter_read_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_counter_reset_all_args:
  """
  Attributes:
   - cxt_id
   - counter_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'counter_name', None, None, ), # 2
  )

  def __init__(self, cxt_id=None, counter_name=None,):
    self.cxt_id = cxt_id
    self.counter_name = counter_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.counter_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_counter_reset_all_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.counter_name is not None:
      oprot.writeFieldBegin('counter_name', TType.STRING, 2)
      oprot.writeString(self.counter_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.counter_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_counter_reset_all_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidCounterOperation, InvalidCounterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidCounterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_counter_reset_all_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_counter_write_args:
  """
  Attributes:
   - cxt_id
   - counter_name
   - index
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'counter_name', None, None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'value', (BmCounterValue, BmCounterValue.thrift_spec), None, ), # 4
  )

  def __init__(self, cxt_id=None, counter_name=None, index=None, value=None,):
    self.cxt_id = cxt_id
    self.counter_name = counter_name
    self.index = index
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.counter_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.value = BmCounterValue()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_counter_write_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.counter_name is not None:
      oprot.writeFieldBegin('counter_name', TType.STRING, 2)
      oprot.writeString(self.counter_name)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 4)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.counter_name)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_counter_write_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidCounterOperation, InvalidCounterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidCounterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_counter_write_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_learning_ack_args:
  """
  Attributes:
   - cxt_id
   - list_id
   - buffer_id
   - sample_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.I32, 'list_id', None, None, ), # 2
    (3, TType.I64, 'buffer_id', None, None, ), # 3
    (4, TType.LIST, 'sample_ids', (TType.I32,None), None, ), # 4
  )

  def __init__(self, cxt_id=None, list_id=None, buffer_id=None, sample_ids=None,):
    self.cxt_id = cxt_id
    self.list_id = list_id
    self.buffer_id = buffer_id
    self.sample_ids = sample_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.list_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.buffer_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.sample_ids = []
          (_etype138, _size135) = iprot.readListBegin()
          for _i139 in xrange(_size135):
            _elem140 = iprot.readI32();
            self.sample_ids.append(_elem140)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_learning_ack_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.list_id is not None:
      oprot.writeFieldBegin('list_id', TType.I32, 2)
      oprot.writeI32(self.list_id)
      oprot.writeFieldEnd()
    if self.buffer_id is not None:
      oprot.writeFieldBegin('buffer_id', TType.I64, 3)
      oprot.writeI64(self.buffer_id)
      oprot.writeFieldEnd()
    if self.sample_ids is not None:
      oprot.writeFieldBegin('sample_ids', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.sample_ids))
      for iter141 in self.sample_ids:
        oprot.writeI32(iter141)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.list_id)
    value = (value * 31) ^ hash(self.buffer_id)
    value = (value * 31) ^ hash(self.sample_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_learning_ack_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidLearnOperation, InvalidLearnOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidLearnOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_learning_ack_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_learning_ack_buffer_args:
  """
  Attributes:
   - cxt_id
   - list_id
   - buffer_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.I32, 'list_id', None, None, ), # 2
    (3, TType.I64, 'buffer_id', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, list_id=None, buffer_id=None,):
    self.cxt_id = cxt_id
    self.list_id = list_id
    self.buffer_id = buffer_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.list_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.buffer_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_learning_ack_buffer_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.list_id is not None:
      oprot.writeFieldBegin('list_id', TType.I32, 2)
      oprot.writeI32(self.list_id)
      oprot.writeFieldEnd()
    if self.buffer_id is not None:
      oprot.writeFieldBegin('buffer_id', TType.I64, 3)
      oprot.writeI64(self.buffer_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.list_id)
    value = (value * 31) ^ hash(self.buffer_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_learning_ack_buffer_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidLearnOperation, InvalidLearnOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidLearnOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_learning_ack_buffer_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_learning_set_timeout_args:
  """
  Attributes:
   - cxt_id
   - list_id
   - timeout_ms
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.I32, 'list_id', None, None, ), # 2
    (3, TType.I32, 'timeout_ms', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, list_id=None, timeout_ms=None,):
    self.cxt_id = cxt_id
    self.list_id = list_id
    self.timeout_ms = timeout_ms

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.list_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout_ms = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_learning_set_timeout_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.list_id is not None:
      oprot.writeFieldBegin('list_id', TType.I32, 2)
      oprot.writeI32(self.list_id)
      oprot.writeFieldEnd()
    if self.timeout_ms is not None:
      oprot.writeFieldBegin('timeout_ms', TType.I32, 3)
      oprot.writeI32(self.timeout_ms)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.list_id)
    value = (value * 31) ^ hash(self.timeout_ms)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_learning_set_timeout_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidLearnOperation, InvalidLearnOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidLearnOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_learning_set_timeout_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_learning_set_buffer_size_args:
  """
  Attributes:
   - cxt_id
   - list_id
   - nb_samples
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.I32, 'list_id', None, None, ), # 2
    (3, TType.I32, 'nb_samples', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, list_id=None, nb_samples=None,):
    self.cxt_id = cxt_id
    self.list_id = list_id
    self.nb_samples = nb_samples

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.list_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.nb_samples = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_learning_set_buffer_size_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.list_id is not None:
      oprot.writeFieldBegin('list_id', TType.I32, 2)
      oprot.writeI32(self.list_id)
      oprot.writeFieldEnd()
    if self.nb_samples is not None:
      oprot.writeFieldBegin('nb_samples', TType.I32, 3)
      oprot.writeI32(self.nb_samples)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.list_id)
    value = (value * 31) ^ hash(self.nb_samples)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_learning_set_buffer_size_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidLearnOperation, InvalidLearnOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidLearnOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_learning_set_buffer_size_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_load_new_config_args:
  """
  Attributes:
   - config_str
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'config_str', None, None, ), # 1
  )

  def __init__(self, config_str=None,):
    self.config_str = config_str

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.config_str = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_load_new_config_args')
    if self.config_str is not None:
      oprot.writeFieldBegin('config_str', TType.STRING, 1)
      oprot.writeString(self.config_str)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.config_str)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_load_new_config_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidSwapOperation, InvalidSwapOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSwapOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_load_new_config_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_swap_configs_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_swap_configs_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_swap_configs_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidSwapOperation, InvalidSwapOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSwapOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_swap_configs_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_meter_array_set_rates_args:
  """
  Attributes:
   - cxt_id
   - meter_array_name
   - rates
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'meter_array_name', None, None, ), # 2
    (3, TType.LIST, 'rates', (TType.STRUCT,(BmMeterRateConfig, BmMeterRateConfig.thrift_spec)), None, ), # 3
  )

  def __init__(self, cxt_id=None, meter_array_name=None, rates=None,):
    self.cxt_id = cxt_id
    self.meter_array_name = meter_array_name
    self.rates = rates

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.meter_array_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.rates = []
          (_etype145, _size142) = iprot.readListBegin()
          for _i146 in xrange(_size142):
            _elem147 = BmMeterRateConfig()
            _elem147.read(iprot)
            self.rates.append(_elem147)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_meter_array_set_rates_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.meter_array_name is not None:
      oprot.writeFieldBegin('meter_array_name', TType.STRING, 2)
      oprot.writeString(self.meter_array_name)
      oprot.writeFieldEnd()
    if self.rates is not None:
      oprot.writeFieldBegin('rates', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.rates))
      for iter148 in self.rates:
        iter148.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.meter_array_name)
    value = (value * 31) ^ hash(self.rates)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_meter_array_set_rates_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidMeterOperation, InvalidMeterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidMeterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_meter_array_set_rates_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_meter_set_rates_args:
  """
  Attributes:
   - cxt_id
   - meter_array_name
   - index
   - rates
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'meter_array_name', None, None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.LIST, 'rates', (TType.STRUCT,(BmMeterRateConfig, BmMeterRateConfig.thrift_spec)), None, ), # 4
  )

  def __init__(self, cxt_id=None, meter_array_name=None, index=None, rates=None,):
    self.cxt_id = cxt_id
    self.meter_array_name = meter_array_name
    self.index = index
    self.rates = rates

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.meter_array_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.rates = []
          (_etype152, _size149) = iprot.readListBegin()
          for _i153 in xrange(_size149):
            _elem154 = BmMeterRateConfig()
            _elem154.read(iprot)
            self.rates.append(_elem154)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_meter_set_rates_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.meter_array_name is not None:
      oprot.writeFieldBegin('meter_array_name', TType.STRING, 2)
      oprot.writeString(self.meter_array_name)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.rates is not None:
      oprot.writeFieldBegin('rates', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.rates))
      for iter155 in self.rates:
        iter155.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.meter_array_name)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.rates)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_meter_set_rates_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidMeterOperation, InvalidMeterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidMeterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_meter_set_rates_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_meter_get_rates_args:
  """
  Attributes:
   - cxt_id
   - meter_array_name
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'meter_array_name', None, None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, meter_array_name=None, index=None,):
    self.cxt_id = cxt_id
    self.meter_array_name = meter_array_name
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.meter_array_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_meter_get_rates_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.meter_array_name is not None:
      oprot.writeFieldBegin('meter_array_name', TType.STRING, 2)
      oprot.writeString(self.meter_array_name)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.meter_array_name)
    value = (value * 31) ^ hash(self.index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_meter_get_rates_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(BmMeterRateConfig, BmMeterRateConfig.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidMeterOperation, InvalidMeterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype159, _size156) = iprot.readListBegin()
          for _i160 in xrange(_size156):
            _elem161 = BmMeterRateConfig()
            _elem161.read(iprot)
            self.success.append(_elem161)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidMeterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_meter_get_rates_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter162 in self.success:
        iter162.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_register_read_args:
  """
  Attributes:
   - cxt_id
   - register_array_name
   - idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'register_array_name', None, None, ), # 2
    (3, TType.I32, 'idx', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, register_array_name=None, idx=None,):
    self.cxt_id = cxt_id
    self.register_array_name = register_array_name
    self.idx = idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.register_array_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.idx = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_register_read_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.register_array_name is not None:
      oprot.writeFieldBegin('register_array_name', TType.STRING, 2)
      oprot.writeString(self.register_array_name)
      oprot.writeFieldEnd()
    if self.idx is not None:
      oprot.writeFieldBegin('idx', TType.I32, 3)
      oprot.writeI32(self.idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.register_array_name)
    value = (value * 31) ^ hash(self.idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_register_read_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_register_read_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_register_write_args:
  """
  Attributes:
   - cxt_id
   - register_array_name
   - index
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'register_array_name', None, None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I64, 'value', None, None, ), # 4
  )

  def __init__(self, cxt_id=None, register_array_name=None, index=None, value=None,):
    self.cxt_id = cxt_id
    self.register_array_name = register_array_name
    self.index = index
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.register_array_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.value = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_register_write_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.register_array_name is not None:
      oprot.writeFieldBegin('register_array_name', TType.STRING, 2)
      oprot.writeString(self.register_array_name)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 4)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.register_array_name)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_register_write_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_register_write_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_register_write_range_args:
  """
  Attributes:
   - cxt_id
   - register_array_name
   - start_index
   - end_index
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'register_array_name', None, None, ), # 2
    (3, TType.I32, 'start_index', None, None, ), # 3
    (4, TType.I32, 'end_index', None, None, ), # 4
    (5, TType.I64, 'value', None, None, ), # 5
  )

  def __init__(self, cxt_id=None, register_array_name=None, start_index=None, end_index=None, value=None,):
    self.cxt_id = cxt_id
    self.register_array_name = register_array_name
    self.start_index = start_index
    self.end_index = end_index
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.register_array_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.start_index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.end_index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.value = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_register_write_range_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.register_array_name is not None:
      oprot.writeFieldBegin('register_array_name', TType.STRING, 2)
      oprot.writeString(self.register_array_name)
      oprot.writeFieldEnd()
    if self.start_index is not None:
      oprot.writeFieldBegin('start_index', TType.I32, 3)
      oprot.writeI32(self.start_index)
      oprot.writeFieldEnd()
    if self.end_index is not None:
      oprot.writeFieldBegin('end_index', TType.I32, 4)
      oprot.writeI32(self.end_index)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 5)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.register_array_name)
    value = (value * 31) ^ hash(self.start_index)
    value = (value * 31) ^ hash(self.end_index)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_register_write_range_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_register_write_range_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_register_reset_args:
  """
  Attributes:
   - cxt_id
   - register_array_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'register_array_name', None, None, ), # 2
  )

  def __init__(self, cxt_id=None, register_array_name=None,):
    self.cxt_id = cxt_id
    self.register_array_name = register_array_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.register_array_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_register_reset_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.register_array_name is not None:
      oprot.writeFieldBegin('register_array_name', TType.STRING, 2)
      oprot.writeString(self.register_array_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.register_array_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_register_reset_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_register_reset_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_parse_vset_add_args:
  """
  Attributes:
   - cxt_id
   - parse_vset_name
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'parse_vset_name', None, None, ), # 2
    (3, TType.STRING, 'value', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, parse_vset_name=None, value=None,):
    self.cxt_id = cxt_id
    self.parse_vset_name = parse_vset_name
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.parse_vset_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_parse_vset_add_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.parse_vset_name is not None:
      oprot.writeFieldBegin('parse_vset_name', TType.STRING, 2)
      oprot.writeString(self.parse_vset_name)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.parse_vset_name)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_parse_vset_add_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidParseVSetOperation, InvalidParseVSetOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidParseVSetOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_parse_vset_add_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_parse_vset_remove_args:
  """
  Attributes:
   - cxt_id
   - parse_vset_name
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'parse_vset_name', None, None, ), # 2
    (3, TType.STRING, 'value', None, None, ), # 3
  )

  def __init__(self, cxt_id=None, parse_vset_name=None, value=None,):
    self.cxt_id = cxt_id
    self.parse_vset_name = parse_vset_name
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.parse_vset_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_parse_vset_remove_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.parse_vset_name is not None:
      oprot.writeFieldBegin('parse_vset_name', TType.STRING, 2)
      oprot.writeString(self.parse_vset_name)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.parse_vset_name)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_parse_vset_remove_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidParseVSetOperation, InvalidParseVSetOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidParseVSetOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_parse_vset_remove_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_dev_mgr_add_port_args:
  """
  Attributes:
   - iface_name
   - port_num
   - pcap_path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'iface_name', None, None, ), # 1
    (2, TType.I32, 'port_num', None, None, ), # 2
    (3, TType.STRING, 'pcap_path', None, None, ), # 3
  )

  def __init__(self, iface_name=None, port_num=None, pcap_path=None,):
    self.iface_name = iface_name
    self.port_num = port_num
    self.pcap_path = pcap_path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.iface_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pcap_path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_dev_mgr_add_port_args')
    if self.iface_name is not None:
      oprot.writeFieldBegin('iface_name', TType.STRING, 1)
      oprot.writeString(self.iface_name)
      oprot.writeFieldEnd()
    if self.port_num is not None:
      oprot.writeFieldBegin('port_num', TType.I32, 2)
      oprot.writeI32(self.port_num)
      oprot.writeFieldEnd()
    if self.pcap_path is not None:
      oprot.writeFieldBegin('pcap_path', TType.STRING, 3)
      oprot.writeString(self.pcap_path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.iface_name)
    value = (value * 31) ^ hash(self.port_num)
    value = (value * 31) ^ hash(self.pcap_path)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_dev_mgr_add_port_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidDevMgrOperation, InvalidDevMgrOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidDevMgrOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_dev_mgr_add_port_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_dev_mgr_remove_port_args:
  """
  Attributes:
   - port_num
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'port_num', None, None, ), # 1
  )

  def __init__(self, port_num=None,):
    self.port_num = port_num

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.port_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_dev_mgr_remove_port_args')
    if self.port_num is not None:
      oprot.writeFieldBegin('port_num', TType.I32, 1)
      oprot.writeI32(self.port_num)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.port_num)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_dev_mgr_remove_port_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidDevMgrOperation, InvalidDevMgrOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidDevMgrOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_dev_mgr_remove_port_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_dev_mgr_show_ports_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_dev_mgr_show_ports_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_dev_mgr_show_ports_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(DevMgrPortInfo, DevMgrPortInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidDevMgrOperation, InvalidDevMgrOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype166, _size163) = iprot.readListBegin()
          for _i167 in xrange(_size163):
            _elem168 = DevMgrPortInfo()
            _elem168.read(iprot)
            self.success.append(_elem168)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidDevMgrOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_dev_mgr_show_ports_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter169 in self.success:
        iter169.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mgmt_get_info_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mgmt_get_info_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_mgmt_get_info_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BmConfig, BmConfig.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BmConfig()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_mgmt_get_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_set_crc16_custom_parameters_args:
  """
  Attributes:
   - cxt_id
   - calc_name
   - crc16_config
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'calc_name', None, None, ), # 2
    (3, TType.STRUCT, 'crc16_config', (BmCrc16Config, BmCrc16Config.thrift_spec), None, ), # 3
  )

  def __init__(self, cxt_id=None, calc_name=None, crc16_config=None,):
    self.cxt_id = cxt_id
    self.calc_name = calc_name
    self.crc16_config = crc16_config

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.calc_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.crc16_config = BmCrc16Config()
          self.crc16_config.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_set_crc16_custom_parameters_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.calc_name is not None:
      oprot.writeFieldBegin('calc_name', TType.STRING, 2)
      oprot.writeString(self.calc_name)
      oprot.writeFieldEnd()
    if self.crc16_config is not None:
      oprot.writeFieldBegin('crc16_config', TType.STRUCT, 3)
      self.crc16_config.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.calc_name)
    value = (value * 31) ^ hash(self.crc16_config)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_set_crc16_custom_parameters_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidCrcOperation, InvalidCrcOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidCrcOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_set_crc16_custom_parameters_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_set_crc32_custom_parameters_args:
  """
  Attributes:
   - cxt_id
   - calc_name
   - crc32_config
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cxt_id', None, None, ), # 1
    (2, TType.STRING, 'calc_name', None, None, ), # 2
    (3, TType.STRUCT, 'crc32_config', (BmCrc32Config, BmCrc32Config.thrift_spec), None, ), # 3
  )

  def __init__(self, cxt_id=None, calc_name=None, crc32_config=None,):
    self.cxt_id = cxt_id
    self.calc_name = calc_name
    self.crc32_config = crc32_config

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cxt_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.calc_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.crc32_config = BmCrc32Config()
          self.crc32_config.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_set_crc32_custom_parameters_args')
    if self.cxt_id is not None:
      oprot.writeFieldBegin('cxt_id', TType.I32, 1)
      oprot.writeI32(self.cxt_id)
      oprot.writeFieldEnd()
    if self.calc_name is not None:
      oprot.writeFieldBegin('calc_name', TType.STRING, 2)
      oprot.writeString(self.calc_name)
      oprot.writeFieldEnd()
    if self.crc32_config is not None:
      oprot.writeFieldBegin('crc32_config', TType.STRUCT, 3)
      self.crc32_config.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cxt_id)
    value = (value * 31) ^ hash(self.calc_name)
    value = (value * 31) ^ hash(self.crc32_config)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_set_crc32_custom_parameters_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidCrcOperation, InvalidCrcOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidCrcOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_set_crc32_custom_parameters_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_reset_state_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_reset_state_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_reset_state_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_reset_state_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_get_config_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_get_config_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_get_config_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_get_config_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_get_config_md5_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_get_config_md5_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_get_config_md5_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_get_config_md5_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_serialize_state_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_serialize_state_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bm_serialize_state_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bm_serialize_state_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
